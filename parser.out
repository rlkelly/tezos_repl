Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EMPTY_MAP
    GET
    LBRACKET
    RBRACKET

Grammar

Rule 0     S' -> statement
Rule 1     statement -> DROP
Rule 2     statement -> DUP
Rule 3     statement -> SWAP
Rule 4     statement -> UNIT
Rule 5     bool -> TRUE
Rule 6     bool -> FALSE
Rule 7     value -> NUMBER
Rule 8     value -> bool
Rule 9     value -> TEXT
Rule 10    value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS
Rule 11    statement -> EQ
Rule 12    statement -> NEQ
Rule 13    statement -> LT
Rule 14    statement -> GT
Rule 15    statement -> LE
Rule 16    statement -> GE
Rule 17    statement -> OR
Rule 18    statement -> AND
Rule 19    statement -> XOR
Rule 20    statement -> COMPARE
Rule 21    statement -> NEG
Rule 22    statement -> ABS
Rule 23    statement -> ADD
Rule 24    statement -> SUB
Rule 25    statement -> MUL
Rule 26    statement -> EDIV
Rule 27    statement -> LSL
Rule 28    statement -> LSR
Rule 29    statement -> CONCAT
Rule 30    statement -> SIZE
Rule 31    statement -> SLICE
Rule 32    statement -> PAIR
Rule 33    statement -> CAR
Rule 34    statement -> CDR
Rule 35    statement -> EMPTY_SET TYPE
Rule 36    statement -> MEM
Rule 37    statement -> UPDATE
Rule 38    statement -> SOME
Rule 39    statement -> NONE TYPE
Rule 40    statement -> LEFT TYPE
Rule 41    statement -> RIGHT TYPE
Rule 42    statement -> CONS
Rule 43    statement -> NIL TYPE
Rule 44    statement -> NOT
Rule 45    TYPE -> NAT
Rule 46    TYPE -> STRING
Rule 47    TYPE -> INT
Rule 48    TYPE -> BOOL
Rule 49    TYPE -> BYTES
Rule 50    TYPE -> LPARENS LPAIR TYPE TYPE RPARENS
Rule 51    statement -> PUSH TYPE value
Rule 52    statement -> FAILWITH

Terminals, with rules where they appear

ABS                  : 22
ADD                  : 23
AND                  : 18
BOOL                 : 48
BYTES                : 49
CAR                  : 33
CDR                  : 34
COMPARE              : 20
CONCAT               : 29
CONS                 : 42
DROP                 : 1
DUP                  : 2
EDIV                 : 26
EMPTY_MAP            : 
EMPTY_SET            : 35
EQ                   : 11
FAILWITH             : 52
FALSE                : 6
GE                   : 16
GET                  : 
GT                   : 14
INT                  : 47
LBRACKET             : 
LE                   : 15
LEFT                 : 40
LPAIR                : 50
LPARENS              : 10 50
LSL                  : 27
LSR                  : 28
LT                   : 13
MEM                  : 36
MUL                  : 25
NAT                  : 45
NEG                  : 21
NEQ                  : 12
NIL                  : 43
NONE                 : 39
NOT                  : 44
NUMBER               : 7
OR                   : 17
PAIR                 : 32
PAIR_CONSTRUCTOR     : 10
PUSH                 : 51
RBRACKET             : 
RIGHT                : 41
RPARENS              : 10 50
SIZE                 : 30
SLICE                : 31
SOME                 : 38
STRING               : 46
SUB                  : 24
SWAP                 : 3
TEXT                 : 9
TRUE                 : 5
UNIT                 : 4
UPDATE               : 37
XOR                  : 19
error                : 

Nonterminals, with rules where they appear

TYPE                 : 35 39 40 41 43 50 50 51
bool                 : 8
statement            : 0
value                : 10 10 51

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . DROP
    (2) statement -> . DUP
    (3) statement -> . SWAP
    (4) statement -> . UNIT
    (11) statement -> . EQ
    (12) statement -> . NEQ
    (13) statement -> . LT
    (14) statement -> . GT
    (15) statement -> . LE
    (16) statement -> . GE
    (17) statement -> . OR
    (18) statement -> . AND
    (19) statement -> . XOR
    (20) statement -> . COMPARE
    (21) statement -> . NEG
    (22) statement -> . ABS
    (23) statement -> . ADD
    (24) statement -> . SUB
    (25) statement -> . MUL
    (26) statement -> . EDIV
    (27) statement -> . LSL
    (28) statement -> . LSR
    (29) statement -> . CONCAT
    (30) statement -> . SIZE
    (31) statement -> . SLICE
    (32) statement -> . PAIR
    (33) statement -> . CAR
    (34) statement -> . CDR
    (35) statement -> . EMPTY_SET TYPE
    (36) statement -> . MEM
    (37) statement -> . UPDATE
    (38) statement -> . SOME
    (39) statement -> . NONE TYPE
    (40) statement -> . LEFT TYPE
    (41) statement -> . RIGHT TYPE
    (42) statement -> . CONS
    (43) statement -> . NIL TYPE
    (44) statement -> . NOT
    (51) statement -> . PUSH TYPE value
    (52) statement -> . FAILWITH

    DROP            shift and go to state 2
    DUP             shift and go to state 3
    SWAP            shift and go to state 4
    UNIT            shift and go to state 5
    EQ              shift and go to state 6
    NEQ             shift and go to state 7
    LT              shift and go to state 8
    GT              shift and go to state 9
    LE              shift and go to state 10
    GE              shift and go to state 11
    OR              shift and go to state 12
    AND             shift and go to state 13
    XOR             shift and go to state 14
    COMPARE         shift and go to state 15
    NEG             shift and go to state 16
    ABS             shift and go to state 17
    ADD             shift and go to state 18
    SUB             shift and go to state 19
    MUL             shift and go to state 20
    EDIV            shift and go to state 21
    LSL             shift and go to state 22
    LSR             shift and go to state 23
    CONCAT          shift and go to state 24
    SIZE            shift and go to state 25
    SLICE           shift and go to state 26
    PAIR            shift and go to state 27
    CAR             shift and go to state 28
    CDR             shift and go to state 29
    EMPTY_SET       shift and go to state 30
    MEM             shift and go to state 31
    UPDATE          shift and go to state 32
    SOME            shift and go to state 33
    NONE            shift and go to state 34
    LEFT            shift and go to state 35
    RIGHT           shift and go to state 36
    CONS            shift and go to state 37
    NIL             shift and go to state 38
    NOT             shift and go to state 39
    PUSH            shift and go to state 40
    FAILWITH        shift and go to state 41

    statement                      shift and go to state 1

state 1

    (0) S' -> statement .



state 2

    (1) statement -> DROP .

    $end            reduce using rule 1 (statement -> DROP .)


state 3

    (2) statement -> DUP .

    $end            reduce using rule 2 (statement -> DUP .)


state 4

    (3) statement -> SWAP .

    $end            reduce using rule 3 (statement -> SWAP .)


state 5

    (4) statement -> UNIT .

    $end            reduce using rule 4 (statement -> UNIT .)


state 6

    (11) statement -> EQ .

    $end            reduce using rule 11 (statement -> EQ .)


state 7

    (12) statement -> NEQ .

    $end            reduce using rule 12 (statement -> NEQ .)


state 8

    (13) statement -> LT .

    $end            reduce using rule 13 (statement -> LT .)


state 9

    (14) statement -> GT .

    $end            reduce using rule 14 (statement -> GT .)


state 10

    (15) statement -> LE .

    $end            reduce using rule 15 (statement -> LE .)


state 11

    (16) statement -> GE .

    $end            reduce using rule 16 (statement -> GE .)


state 12

    (17) statement -> OR .

    $end            reduce using rule 17 (statement -> OR .)


state 13

    (18) statement -> AND .

    $end            reduce using rule 18 (statement -> AND .)


state 14

    (19) statement -> XOR .

    $end            reduce using rule 19 (statement -> XOR .)


state 15

    (20) statement -> COMPARE .

    $end            reduce using rule 20 (statement -> COMPARE .)


state 16

    (21) statement -> NEG .

    $end            reduce using rule 21 (statement -> NEG .)


state 17

    (22) statement -> ABS .

    $end            reduce using rule 22 (statement -> ABS .)


state 18

    (23) statement -> ADD .

    $end            reduce using rule 23 (statement -> ADD .)


state 19

    (24) statement -> SUB .

    $end            reduce using rule 24 (statement -> SUB .)


state 20

    (25) statement -> MUL .

    $end            reduce using rule 25 (statement -> MUL .)


state 21

    (26) statement -> EDIV .

    $end            reduce using rule 26 (statement -> EDIV .)


state 22

    (27) statement -> LSL .

    $end            reduce using rule 27 (statement -> LSL .)


state 23

    (28) statement -> LSR .

    $end            reduce using rule 28 (statement -> LSR .)


state 24

    (29) statement -> CONCAT .

    $end            reduce using rule 29 (statement -> CONCAT .)


state 25

    (30) statement -> SIZE .

    $end            reduce using rule 30 (statement -> SIZE .)


state 26

    (31) statement -> SLICE .

    $end            reduce using rule 31 (statement -> SLICE .)


state 27

    (32) statement -> PAIR .

    $end            reduce using rule 32 (statement -> PAIR .)


state 28

    (33) statement -> CAR .

    $end            reduce using rule 33 (statement -> CAR .)


state 29

    (34) statement -> CDR .

    $end            reduce using rule 34 (statement -> CDR .)


state 30

    (35) statement -> EMPTY_SET . TYPE
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 42

state 31

    (36) statement -> MEM .

    $end            reduce using rule 36 (statement -> MEM .)


state 32

    (37) statement -> UPDATE .

    $end            reduce using rule 37 (statement -> UPDATE .)


state 33

    (38) statement -> SOME .

    $end            reduce using rule 38 (statement -> SOME .)


state 34

    (39) statement -> NONE . TYPE
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 49

state 35

    (40) statement -> LEFT . TYPE
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 50

state 36

    (41) statement -> RIGHT . TYPE
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 51

state 37

    (42) statement -> CONS .

    $end            reduce using rule 42 (statement -> CONS .)


state 38

    (43) statement -> NIL . TYPE
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 52

state 39

    (44) statement -> NOT .

    $end            reduce using rule 44 (statement -> NOT .)


state 40

    (51) statement -> PUSH . TYPE value
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 53

state 41

    (52) statement -> FAILWITH .

    $end            reduce using rule 52 (statement -> FAILWITH .)


state 42

    (35) statement -> EMPTY_SET TYPE .

    $end            reduce using rule 35 (statement -> EMPTY_SET TYPE .)


state 43

    (45) TYPE -> NAT .

    $end            reduce using rule 45 (TYPE -> NAT .)
    NUMBER          reduce using rule 45 (TYPE -> NAT .)
    TEXT            reduce using rule 45 (TYPE -> NAT .)
    LPARENS         reduce using rule 45 (TYPE -> NAT .)
    TRUE            reduce using rule 45 (TYPE -> NAT .)
    FALSE           reduce using rule 45 (TYPE -> NAT .)
    NAT             reduce using rule 45 (TYPE -> NAT .)
    STRING          reduce using rule 45 (TYPE -> NAT .)
    INT             reduce using rule 45 (TYPE -> NAT .)
    BOOL            reduce using rule 45 (TYPE -> NAT .)
    BYTES           reduce using rule 45 (TYPE -> NAT .)
    RPARENS         reduce using rule 45 (TYPE -> NAT .)


state 44

    (46) TYPE -> STRING .

    $end            reduce using rule 46 (TYPE -> STRING .)
    NUMBER          reduce using rule 46 (TYPE -> STRING .)
    TEXT            reduce using rule 46 (TYPE -> STRING .)
    LPARENS         reduce using rule 46 (TYPE -> STRING .)
    TRUE            reduce using rule 46 (TYPE -> STRING .)
    FALSE           reduce using rule 46 (TYPE -> STRING .)
    NAT             reduce using rule 46 (TYPE -> STRING .)
    STRING          reduce using rule 46 (TYPE -> STRING .)
    INT             reduce using rule 46 (TYPE -> STRING .)
    BOOL            reduce using rule 46 (TYPE -> STRING .)
    BYTES           reduce using rule 46 (TYPE -> STRING .)
    RPARENS         reduce using rule 46 (TYPE -> STRING .)


state 45

    (47) TYPE -> INT .

    $end            reduce using rule 47 (TYPE -> INT .)
    NUMBER          reduce using rule 47 (TYPE -> INT .)
    TEXT            reduce using rule 47 (TYPE -> INT .)
    LPARENS         reduce using rule 47 (TYPE -> INT .)
    TRUE            reduce using rule 47 (TYPE -> INT .)
    FALSE           reduce using rule 47 (TYPE -> INT .)
    NAT             reduce using rule 47 (TYPE -> INT .)
    STRING          reduce using rule 47 (TYPE -> INT .)
    INT             reduce using rule 47 (TYPE -> INT .)
    BOOL            reduce using rule 47 (TYPE -> INT .)
    BYTES           reduce using rule 47 (TYPE -> INT .)
    RPARENS         reduce using rule 47 (TYPE -> INT .)


state 46

    (48) TYPE -> BOOL .

    $end            reduce using rule 48 (TYPE -> BOOL .)
    NUMBER          reduce using rule 48 (TYPE -> BOOL .)
    TEXT            reduce using rule 48 (TYPE -> BOOL .)
    LPARENS         reduce using rule 48 (TYPE -> BOOL .)
    TRUE            reduce using rule 48 (TYPE -> BOOL .)
    FALSE           reduce using rule 48 (TYPE -> BOOL .)
    NAT             reduce using rule 48 (TYPE -> BOOL .)
    STRING          reduce using rule 48 (TYPE -> BOOL .)
    INT             reduce using rule 48 (TYPE -> BOOL .)
    BOOL            reduce using rule 48 (TYPE -> BOOL .)
    BYTES           reduce using rule 48 (TYPE -> BOOL .)
    RPARENS         reduce using rule 48 (TYPE -> BOOL .)


state 47

    (49) TYPE -> BYTES .

    $end            reduce using rule 49 (TYPE -> BYTES .)
    NUMBER          reduce using rule 49 (TYPE -> BYTES .)
    TEXT            reduce using rule 49 (TYPE -> BYTES .)
    LPARENS         reduce using rule 49 (TYPE -> BYTES .)
    TRUE            reduce using rule 49 (TYPE -> BYTES .)
    FALSE           reduce using rule 49 (TYPE -> BYTES .)
    NAT             reduce using rule 49 (TYPE -> BYTES .)
    STRING          reduce using rule 49 (TYPE -> BYTES .)
    INT             reduce using rule 49 (TYPE -> BYTES .)
    BOOL            reduce using rule 49 (TYPE -> BYTES .)
    BYTES           reduce using rule 49 (TYPE -> BYTES .)
    RPARENS         reduce using rule 49 (TYPE -> BYTES .)


state 48

    (50) TYPE -> LPARENS . LPAIR TYPE TYPE RPARENS

    LPAIR           shift and go to state 54


state 49

    (39) statement -> NONE TYPE .

    $end            reduce using rule 39 (statement -> NONE TYPE .)


state 50

    (40) statement -> LEFT TYPE .

    $end            reduce using rule 40 (statement -> LEFT TYPE .)


state 51

    (41) statement -> RIGHT TYPE .

    $end            reduce using rule 41 (statement -> RIGHT TYPE .)


state 52

    (43) statement -> NIL TYPE .

    $end            reduce using rule 43 (statement -> NIL TYPE .)


state 53

    (51) statement -> PUSH TYPE . value
    (7) value -> . NUMBER
    (8) value -> . bool
    (9) value -> . TEXT
    (10) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (5) bool -> . TRUE
    (6) bool -> . FALSE

    NUMBER          shift and go to state 56
    TEXT            shift and go to state 58
    LPARENS         shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61

    value                          shift and go to state 55
    bool                           shift and go to state 57

state 54

    (50) TYPE -> LPARENS LPAIR . TYPE TYPE RPARENS
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 62

state 55

    (51) statement -> PUSH TYPE value .

    $end            reduce using rule 51 (statement -> PUSH TYPE value .)


state 56

    (7) value -> NUMBER .

    $end            reduce using rule 7 (value -> NUMBER .)
    NUMBER          reduce using rule 7 (value -> NUMBER .)
    TEXT            reduce using rule 7 (value -> NUMBER .)
    LPARENS         reduce using rule 7 (value -> NUMBER .)
    TRUE            reduce using rule 7 (value -> NUMBER .)
    FALSE           reduce using rule 7 (value -> NUMBER .)
    RPARENS         reduce using rule 7 (value -> NUMBER .)


state 57

    (8) value -> bool .

    $end            reduce using rule 8 (value -> bool .)
    NUMBER          reduce using rule 8 (value -> bool .)
    TEXT            reduce using rule 8 (value -> bool .)
    LPARENS         reduce using rule 8 (value -> bool .)
    TRUE            reduce using rule 8 (value -> bool .)
    FALSE           reduce using rule 8 (value -> bool .)
    RPARENS         reduce using rule 8 (value -> bool .)


state 58

    (9) value -> TEXT .

    $end            reduce using rule 9 (value -> TEXT .)
    NUMBER          reduce using rule 9 (value -> TEXT .)
    TEXT            reduce using rule 9 (value -> TEXT .)
    LPARENS         reduce using rule 9 (value -> TEXT .)
    TRUE            reduce using rule 9 (value -> TEXT .)
    FALSE           reduce using rule 9 (value -> TEXT .)
    RPARENS         reduce using rule 9 (value -> TEXT .)


state 59

    (10) value -> LPARENS . PAIR_CONSTRUCTOR value value RPARENS

    PAIR_CONSTRUCTOR shift and go to state 63


state 60

    (5) bool -> TRUE .

    $end            reduce using rule 5 (bool -> TRUE .)
    NUMBER          reduce using rule 5 (bool -> TRUE .)
    TEXT            reduce using rule 5 (bool -> TRUE .)
    LPARENS         reduce using rule 5 (bool -> TRUE .)
    TRUE            reduce using rule 5 (bool -> TRUE .)
    FALSE           reduce using rule 5 (bool -> TRUE .)
    RPARENS         reduce using rule 5 (bool -> TRUE .)


state 61

    (6) bool -> FALSE .

    $end            reduce using rule 6 (bool -> FALSE .)
    NUMBER          reduce using rule 6 (bool -> FALSE .)
    TEXT            reduce using rule 6 (bool -> FALSE .)
    LPARENS         reduce using rule 6 (bool -> FALSE .)
    TRUE            reduce using rule 6 (bool -> FALSE .)
    FALSE           reduce using rule 6 (bool -> FALSE .)
    RPARENS         reduce using rule 6 (bool -> FALSE .)


state 62

    (50) TYPE -> LPARENS LPAIR TYPE . TYPE RPARENS
    (45) TYPE -> . NAT
    (46) TYPE -> . STRING
    (47) TYPE -> . INT
    (48) TYPE -> . BOOL
    (49) TYPE -> . BYTES
    (50) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47
    LPARENS         shift and go to state 48

    TYPE                           shift and go to state 64

state 63

    (10) value -> LPARENS PAIR_CONSTRUCTOR . value value RPARENS
    (7) value -> . NUMBER
    (8) value -> . bool
    (9) value -> . TEXT
    (10) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (5) bool -> . TRUE
    (6) bool -> . FALSE

    NUMBER          shift and go to state 56
    TEXT            shift and go to state 58
    LPARENS         shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61

    value                          shift and go to state 65
    bool                           shift and go to state 57

state 64

    (50) TYPE -> LPARENS LPAIR TYPE TYPE . RPARENS

    RPARENS         shift and go to state 66


state 65

    (10) value -> LPARENS PAIR_CONSTRUCTOR value . value RPARENS
    (7) value -> . NUMBER
    (8) value -> . bool
    (9) value -> . TEXT
    (10) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (5) bool -> . TRUE
    (6) bool -> . FALSE

    NUMBER          shift and go to state 56
    TEXT            shift and go to state 58
    LPARENS         shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61

    value                          shift and go to state 67
    bool                           shift and go to state 57

state 66

    (50) TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .

    $end            reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    NUMBER          reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    TEXT            reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    LPARENS         reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    TRUE            reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    FALSE           reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    NAT             reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    STRING          reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    INT             reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    BOOL            reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    BYTES           reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    RPARENS         reduce using rule 50 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)


state 67

    (10) value -> LPARENS PAIR_CONSTRUCTOR value value . RPARENS

    RPARENS         shift and go to state 68


state 68

    (10) value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .

    $end            reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    NUMBER          reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TEXT            reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    LPARENS         reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TRUE            reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    FALSE           reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RPARENS         reduce using rule 10 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)

