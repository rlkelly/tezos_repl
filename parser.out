Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MUTEZ

Grammar

Rule 0     S' -> contract_run
Rule 1     contract_run -> contract_decl code_decl
Rule 2     contract_run -> execution
Rule 3     contract_decl -> PARAMETER type SCOLON STORAGE type SCOLON
Rule 4     code_decl -> CODE body
Rule 5     execution -> compound_statement
Rule 6     execution -> compound_statement SCOLON
Rule 7     execution -> body
Rule 8     compound_statement -> stmt
Rule 9     compound_statement -> compound_statement SCOLON stmt
Rule 10    body -> LBRACKET compound_statement SCOLON RBRACKET
Rule 11    body -> LBRACKET compound_statement RBRACKET
Rule 12    body -> LBRACKET RBRACKET
Rule 13    stmt -> LAMBDA type type body
Rule 14    stmt -> DROP
Rule 15    stmt -> DUP
Rule 16    stmt -> SWAP
Rule 17    stmt -> UNIT
Rule 18    bool -> TRUE
Rule 19    bool -> FALSE
Rule 20    value -> NUMBER
Rule 21    value -> bool
Rule 22    value -> TEXT
Rule 23    value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS
Rule 24    stmt -> EQ
Rule 25    stmt -> NEQ
Rule 26    stmt -> LT
Rule 27    stmt -> GT
Rule 28    stmt -> LE
Rule 29    stmt -> GE
Rule 30    stmt -> OR
Rule 31    stmt -> AND
Rule 32    stmt -> XOR
Rule 33    stmt -> COMPARE
Rule 34    stmt -> NEG
Rule 35    stmt -> ABS
Rule 36    stmt -> ADD
Rule 37    stmt -> SUB
Rule 38    stmt -> MUL
Rule 39    stmt -> EDIV
Rule 40    stmt -> LSL
Rule 41    stmt -> LSR
Rule 42    stmt -> SIZE
Rule 43    stmt -> CONCAT
Rule 44    stmt -> SLICE
Rule 45    stmt -> PAIR
Rule 46    stmt -> CAR
Rule 47    stmt -> CDR
Rule 48    stmt -> EMPTY_SET type
Rule 49    stmt -> MEM
Rule 50    stmt -> UPDATE
Rule 51    stmt -> EMPTY_MAP type type
Rule 52    stmt -> MAP body
Rule 53    stmt -> ITER body
Rule 54    stmt -> GET
Rule 55    stmt -> IF_LEFT body body
Rule 56    stmt -> IF_RIGHT body body
Rule 57    stmt -> IF_CONS body body
Rule 58    stmt -> SOME
Rule 59    stmt -> NONE type
Rule 60    stmt -> LEFT type
Rule 61    stmt -> RIGHT type
Rule 62    stmt -> CONS
Rule 63    stmt -> NIL type
Rule 64    stmt -> NOT
Rule 65    stmt -> EXEC
Rule 66    stmt -> STEPS_TO_QUOTA
Rule 67    stmt -> NOW
Rule 68    stmt -> CONTRACT type
Rule 69    stmt -> HASH_KEY
Rule 70    stmt -> BLAKE2B
Rule 71    stmt -> SHA256
Rule 72    stmt -> SHA512
Rule 73    stmt -> CHECK_SIGNATURE
Rule 74    type -> NAT
Rule 75    type -> STRING
Rule 76    type -> INT
Rule 77    type -> BOOL
Rule 78    type -> BYTES
Rule 79    type -> OPERATION
Rule 80    type -> ADDRESS
Rule 81    type -> TIMESTAMP
Rule 82    type -> LPARENS LPAIR type type RPARENS
Rule 83    stmt -> DIP body
Rule 84    stmt -> PUSH type value
Rule 85    stmt -> ASSERT
Rule 86    stmt -> ASSERT_EQ
Rule 87    stmt -> ASSERT_NEQ
Rule 88    stmt -> ASSERT_LT
Rule 89    stmt -> ASSERT_LTE
Rule 90    stmt -> ASSERT_GT
Rule 91    stmt -> ASSERT_GTE
Rule 92    stmt -> FAILWITH
Rule 93    stmt -> FAIL
Rule 94    stmt -> PRINTER

Terminals, with rules where they appear

ABS                  : 35
ADD                  : 36
ADDRESS              : 80
AND                  : 31
ASSERT               : 85
ASSERT_EQ            : 86
ASSERT_GT            : 90
ASSERT_GTE           : 91
ASSERT_LT            : 88
ASSERT_LTE           : 89
ASSERT_NEQ           : 87
BLAKE2B              : 70
BOOL                 : 77
BYTES                : 78
CAR                  : 46
CDR                  : 47
CHECK_SIGNATURE      : 73
CODE                 : 4
COMPARE              : 33
CONCAT               : 43
CONS                 : 62
CONTRACT             : 68
DIP                  : 83
DROP                 : 14
DUP                  : 15
EDIV                 : 39
EMPTY_MAP            : 51
EMPTY_SET            : 48
EQ                   : 24
EXEC                 : 65
FAIL                 : 93
FAILWITH             : 92
FALSE                : 19
GE                   : 29
GET                  : 54
GT                   : 27
HASH_KEY             : 69
IF_CONS              : 57
IF_LEFT              : 55
IF_RIGHT             : 56
INT                  : 76
ITER                 : 53
LAMBDA               : 13
LBRACKET             : 10 11 12
LE                   : 28
LEFT                 : 60
LPAIR                : 82
LPARENS              : 23 82
LSL                  : 40
LSR                  : 41
LT                   : 26
MAP                  : 52
MEM                  : 49
MUL                  : 38
MUTEZ                : 
NAT                  : 74
NEG                  : 34
NEQ                  : 25
NIL                  : 63
NONE                 : 59
NOT                  : 64
NOW                  : 67
NUMBER               : 20
OPERATION            : 79
OR                   : 30
PAIR                 : 45
PAIR_CONSTRUCTOR     : 23
PARAMETER            : 3
PRINTER              : 94
PUSH                 : 84
RBRACKET             : 10 11 12
RIGHT                : 61
RPARENS              : 23 82
SCOLON               : 3 3 6 9 10
SHA256               : 71
SHA512               : 72
SIZE                 : 42
SLICE                : 44
SOME                 : 58
STEPS_TO_QUOTA       : 66
STORAGE              : 3
STRING               : 75
SUB                  : 37
SWAP                 : 16
TEXT                 : 22
TIMESTAMP            : 81
TRUE                 : 18
UNIT                 : 17
UPDATE               : 50
XOR                  : 32
error                : 

Nonterminals, with rules where they appear

body                 : 4 7 13 52 53 55 55 56 56 57 57 83
bool                 : 21
code_decl            : 1
compound_statement   : 5 6 9 10 11
contract_decl        : 1
contract_run         : 0
execution            : 2
stmt                 : 8 9
type                 : 3 3 13 13 48 51 51 59 60 61 63 68 82 82 84
value                : 23 23 84

Parsing method: LALR

state 0

    (0) S' -> . contract_run
    (1) contract_run -> . contract_decl code_decl
    (2) contract_run -> . execution
    (3) contract_decl -> . PARAMETER type SCOLON STORAGE type SCOLON
    (5) execution -> . compound_statement
    (6) execution -> . compound_statement SCOLON
    (7) execution -> . body
    (8) compound_statement -> . stmt
    (9) compound_statement -> . compound_statement SCOLON stmt
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_LEFT body body
    (56) stmt -> . IF_RIGHT body body
    (57) stmt -> . IF_CONS body body
    (58) stmt -> . SOME
    (59) stmt -> . NONE type
    (60) stmt -> . LEFT type
    (61) stmt -> . RIGHT type
    (62) stmt -> . CONS
    (63) stmt -> . NIL type
    (64) stmt -> . NOT
    (65) stmt -> . EXEC
    (66) stmt -> . STEPS_TO_QUOTA
    (67) stmt -> . NOW
    (68) stmt -> . CONTRACT type
    (69) stmt -> . HASH_KEY
    (70) stmt -> . BLAKE2B
    (71) stmt -> . SHA256
    (72) stmt -> . SHA512
    (73) stmt -> . CHECK_SIGNATURE
    (83) stmt -> . DIP body
    (84) stmt -> . PUSH type value
    (85) stmt -> . ASSERT
    (86) stmt -> . ASSERT_EQ
    (87) stmt -> . ASSERT_NEQ
    (88) stmt -> . ASSERT_LT
    (89) stmt -> . ASSERT_LTE
    (90) stmt -> . ASSERT_GT
    (91) stmt -> . ASSERT_GTE
    (92) stmt -> . FAILWITH
    (93) stmt -> . FAIL
    (94) stmt -> . PRINTER

    PARAMETER       shift and go to state 4
    LBRACKET        shift and go to state 8
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_LEFT         shift and go to state 45
    IF_RIGHT        shift and go to state 46
    IF_CONS         shift and go to state 47
    SOME            shift and go to state 48
    NONE            shift and go to state 49
    LEFT            shift and go to state 50
    RIGHT           shift and go to state 51
    CONS            shift and go to state 52
    NIL             shift and go to state 53
    NOT             shift and go to state 54
    EXEC            shift and go to state 55
    STEPS_TO_QUOTA  shift and go to state 56
    NOW             shift and go to state 57
    CONTRACT        shift and go to state 58
    HASH_KEY        shift and go to state 59
    BLAKE2B         shift and go to state 60
    SHA256          shift and go to state 61
    SHA512          shift and go to state 62
    CHECK_SIGNATURE shift and go to state 63
    DIP             shift and go to state 64
    PUSH            shift and go to state 65
    ASSERT          shift and go to state 66
    ASSERT_EQ       shift and go to state 67
    ASSERT_NEQ      shift and go to state 68
    ASSERT_LT       shift and go to state 69
    ASSERT_LTE      shift and go to state 70
    ASSERT_GT       shift and go to state 71
    ASSERT_GTE      shift and go to state 72
    FAILWITH        shift and go to state 73
    FAIL            shift and go to state 74
    PRINTER         shift and go to state 75

    contract_run                   shift and go to state 1
    contract_decl                  shift and go to state 2
    execution                      shift and go to state 3
    compound_statement             shift and go to state 5
    body                           shift and go to state 6
    stmt                           shift and go to state 7

state 1

    (0) S' -> contract_run .



state 2

    (1) contract_run -> contract_decl . code_decl
    (4) code_decl -> . CODE body

    CODE            shift and go to state 77

    code_decl                      shift and go to state 76

state 3

    (2) contract_run -> execution .

    $end            reduce using rule 2 (contract_run -> execution .)


state 4

    (3) contract_decl -> PARAMETER . type SCOLON STORAGE type SCOLON
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 78

state 5

    (5) execution -> compound_statement .
    (6) execution -> compound_statement . SCOLON
    (9) compound_statement -> compound_statement . SCOLON stmt

    $end            reduce using rule 5 (execution -> compound_statement .)
    SCOLON          shift and go to state 88


state 6

    (7) execution -> body .

    $end            reduce using rule 7 (execution -> body .)


state 7

    (8) compound_statement -> stmt .

    SCOLON          reduce using rule 8 (compound_statement -> stmt .)
    $end            reduce using rule 8 (compound_statement -> stmt .)
    RBRACKET        reduce using rule 8 (compound_statement -> stmt .)


state 8

    (10) body -> LBRACKET . compound_statement SCOLON RBRACKET
    (11) body -> LBRACKET . compound_statement RBRACKET
    (12) body -> LBRACKET . RBRACKET
    (8) compound_statement -> . stmt
    (9) compound_statement -> . compound_statement SCOLON stmt
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_LEFT body body
    (56) stmt -> . IF_RIGHT body body
    (57) stmt -> . IF_CONS body body
    (58) stmt -> . SOME
    (59) stmt -> . NONE type
    (60) stmt -> . LEFT type
    (61) stmt -> . RIGHT type
    (62) stmt -> . CONS
    (63) stmt -> . NIL type
    (64) stmt -> . NOT
    (65) stmt -> . EXEC
    (66) stmt -> . STEPS_TO_QUOTA
    (67) stmt -> . NOW
    (68) stmt -> . CONTRACT type
    (69) stmt -> . HASH_KEY
    (70) stmt -> . BLAKE2B
    (71) stmt -> . SHA256
    (72) stmt -> . SHA512
    (73) stmt -> . CHECK_SIGNATURE
    (83) stmt -> . DIP body
    (84) stmt -> . PUSH type value
    (85) stmt -> . ASSERT
    (86) stmt -> . ASSERT_EQ
    (87) stmt -> . ASSERT_NEQ
    (88) stmt -> . ASSERT_LT
    (89) stmt -> . ASSERT_LTE
    (90) stmt -> . ASSERT_GT
    (91) stmt -> . ASSERT_GTE
    (92) stmt -> . FAILWITH
    (93) stmt -> . FAIL
    (94) stmt -> . PRINTER

    RBRACKET        shift and go to state 90
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_LEFT         shift and go to state 45
    IF_RIGHT        shift and go to state 46
    IF_CONS         shift and go to state 47
    SOME            shift and go to state 48
    NONE            shift and go to state 49
    LEFT            shift and go to state 50
    RIGHT           shift and go to state 51
    CONS            shift and go to state 52
    NIL             shift and go to state 53
    NOT             shift and go to state 54
    EXEC            shift and go to state 55
    STEPS_TO_QUOTA  shift and go to state 56
    NOW             shift and go to state 57
    CONTRACT        shift and go to state 58
    HASH_KEY        shift and go to state 59
    BLAKE2B         shift and go to state 60
    SHA256          shift and go to state 61
    SHA512          shift and go to state 62
    CHECK_SIGNATURE shift and go to state 63
    DIP             shift and go to state 64
    PUSH            shift and go to state 65
    ASSERT          shift and go to state 66
    ASSERT_EQ       shift and go to state 67
    ASSERT_NEQ      shift and go to state 68
    ASSERT_LT       shift and go to state 69
    ASSERT_LTE      shift and go to state 70
    ASSERT_GT       shift and go to state 71
    ASSERT_GTE      shift and go to state 72
    FAILWITH        shift and go to state 73
    FAIL            shift and go to state 74
    PRINTER         shift and go to state 75

    compound_statement             shift and go to state 89
    stmt                           shift and go to state 7

state 9

    (13) stmt -> LAMBDA . type type body
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 91

state 10

    (14) stmt -> DROP .

    SCOLON          reduce using rule 14 (stmt -> DROP .)
    $end            reduce using rule 14 (stmt -> DROP .)
    RBRACKET        reduce using rule 14 (stmt -> DROP .)


state 11

    (15) stmt -> DUP .

    SCOLON          reduce using rule 15 (stmt -> DUP .)
    $end            reduce using rule 15 (stmt -> DUP .)
    RBRACKET        reduce using rule 15 (stmt -> DUP .)


state 12

    (16) stmt -> SWAP .

    SCOLON          reduce using rule 16 (stmt -> SWAP .)
    $end            reduce using rule 16 (stmt -> SWAP .)
    RBRACKET        reduce using rule 16 (stmt -> SWAP .)


state 13

    (17) stmt -> UNIT .

    SCOLON          reduce using rule 17 (stmt -> UNIT .)
    $end            reduce using rule 17 (stmt -> UNIT .)
    RBRACKET        reduce using rule 17 (stmt -> UNIT .)


state 14

    (24) stmt -> EQ .

    SCOLON          reduce using rule 24 (stmt -> EQ .)
    $end            reduce using rule 24 (stmt -> EQ .)
    RBRACKET        reduce using rule 24 (stmt -> EQ .)


state 15

    (25) stmt -> NEQ .

    SCOLON          reduce using rule 25 (stmt -> NEQ .)
    $end            reduce using rule 25 (stmt -> NEQ .)
    RBRACKET        reduce using rule 25 (stmt -> NEQ .)


state 16

    (26) stmt -> LT .

    SCOLON          reduce using rule 26 (stmt -> LT .)
    $end            reduce using rule 26 (stmt -> LT .)
    RBRACKET        reduce using rule 26 (stmt -> LT .)


state 17

    (27) stmt -> GT .

    SCOLON          reduce using rule 27 (stmt -> GT .)
    $end            reduce using rule 27 (stmt -> GT .)
    RBRACKET        reduce using rule 27 (stmt -> GT .)


state 18

    (28) stmt -> LE .

    SCOLON          reduce using rule 28 (stmt -> LE .)
    $end            reduce using rule 28 (stmt -> LE .)
    RBRACKET        reduce using rule 28 (stmt -> LE .)


state 19

    (29) stmt -> GE .

    SCOLON          reduce using rule 29 (stmt -> GE .)
    $end            reduce using rule 29 (stmt -> GE .)
    RBRACKET        reduce using rule 29 (stmt -> GE .)


state 20

    (30) stmt -> OR .

    SCOLON          reduce using rule 30 (stmt -> OR .)
    $end            reduce using rule 30 (stmt -> OR .)
    RBRACKET        reduce using rule 30 (stmt -> OR .)


state 21

    (31) stmt -> AND .

    SCOLON          reduce using rule 31 (stmt -> AND .)
    $end            reduce using rule 31 (stmt -> AND .)
    RBRACKET        reduce using rule 31 (stmt -> AND .)


state 22

    (32) stmt -> XOR .

    SCOLON          reduce using rule 32 (stmt -> XOR .)
    $end            reduce using rule 32 (stmt -> XOR .)
    RBRACKET        reduce using rule 32 (stmt -> XOR .)


state 23

    (33) stmt -> COMPARE .

    SCOLON          reduce using rule 33 (stmt -> COMPARE .)
    $end            reduce using rule 33 (stmt -> COMPARE .)
    RBRACKET        reduce using rule 33 (stmt -> COMPARE .)


state 24

    (34) stmt -> NEG .

    SCOLON          reduce using rule 34 (stmt -> NEG .)
    $end            reduce using rule 34 (stmt -> NEG .)
    RBRACKET        reduce using rule 34 (stmt -> NEG .)


state 25

    (35) stmt -> ABS .

    SCOLON          reduce using rule 35 (stmt -> ABS .)
    $end            reduce using rule 35 (stmt -> ABS .)
    RBRACKET        reduce using rule 35 (stmt -> ABS .)


state 26

    (36) stmt -> ADD .

    SCOLON          reduce using rule 36 (stmt -> ADD .)
    $end            reduce using rule 36 (stmt -> ADD .)
    RBRACKET        reduce using rule 36 (stmt -> ADD .)


state 27

    (37) stmt -> SUB .

    SCOLON          reduce using rule 37 (stmt -> SUB .)
    $end            reduce using rule 37 (stmt -> SUB .)
    RBRACKET        reduce using rule 37 (stmt -> SUB .)


state 28

    (38) stmt -> MUL .

    SCOLON          reduce using rule 38 (stmt -> MUL .)
    $end            reduce using rule 38 (stmt -> MUL .)
    RBRACKET        reduce using rule 38 (stmt -> MUL .)


state 29

    (39) stmt -> EDIV .

    SCOLON          reduce using rule 39 (stmt -> EDIV .)
    $end            reduce using rule 39 (stmt -> EDIV .)
    RBRACKET        reduce using rule 39 (stmt -> EDIV .)


state 30

    (40) stmt -> LSL .

    SCOLON          reduce using rule 40 (stmt -> LSL .)
    $end            reduce using rule 40 (stmt -> LSL .)
    RBRACKET        reduce using rule 40 (stmt -> LSL .)


state 31

    (41) stmt -> LSR .

    SCOLON          reduce using rule 41 (stmt -> LSR .)
    $end            reduce using rule 41 (stmt -> LSR .)
    RBRACKET        reduce using rule 41 (stmt -> LSR .)


state 32

    (42) stmt -> SIZE .

    SCOLON          reduce using rule 42 (stmt -> SIZE .)
    $end            reduce using rule 42 (stmt -> SIZE .)
    RBRACKET        reduce using rule 42 (stmt -> SIZE .)


state 33

    (43) stmt -> CONCAT .

    SCOLON          reduce using rule 43 (stmt -> CONCAT .)
    $end            reduce using rule 43 (stmt -> CONCAT .)
    RBRACKET        reduce using rule 43 (stmt -> CONCAT .)


state 34

    (44) stmt -> SLICE .

    SCOLON          reduce using rule 44 (stmt -> SLICE .)
    $end            reduce using rule 44 (stmt -> SLICE .)
    RBRACKET        reduce using rule 44 (stmt -> SLICE .)


state 35

    (45) stmt -> PAIR .

    SCOLON          reduce using rule 45 (stmt -> PAIR .)
    $end            reduce using rule 45 (stmt -> PAIR .)
    RBRACKET        reduce using rule 45 (stmt -> PAIR .)


state 36

    (46) stmt -> CAR .

    SCOLON          reduce using rule 46 (stmt -> CAR .)
    $end            reduce using rule 46 (stmt -> CAR .)
    RBRACKET        reduce using rule 46 (stmt -> CAR .)


state 37

    (47) stmt -> CDR .

    SCOLON          reduce using rule 47 (stmt -> CDR .)
    $end            reduce using rule 47 (stmt -> CDR .)
    RBRACKET        reduce using rule 47 (stmt -> CDR .)


state 38

    (48) stmt -> EMPTY_SET . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 92

state 39

    (49) stmt -> MEM .

    SCOLON          reduce using rule 49 (stmt -> MEM .)
    $end            reduce using rule 49 (stmt -> MEM .)
    RBRACKET        reduce using rule 49 (stmt -> MEM .)


state 40

    (50) stmt -> UPDATE .

    SCOLON          reduce using rule 50 (stmt -> UPDATE .)
    $end            reduce using rule 50 (stmt -> UPDATE .)
    RBRACKET        reduce using rule 50 (stmt -> UPDATE .)


state 41

    (51) stmt -> EMPTY_MAP . type type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 93

state 42

    (52) stmt -> MAP . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 94

state 43

    (53) stmt -> ITER . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 95

state 44

    (54) stmt -> GET .

    SCOLON          reduce using rule 54 (stmt -> GET .)
    $end            reduce using rule 54 (stmt -> GET .)
    RBRACKET        reduce using rule 54 (stmt -> GET .)


state 45

    (55) stmt -> IF_LEFT . body body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 96

state 46

    (56) stmt -> IF_RIGHT . body body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 97

state 47

    (57) stmt -> IF_CONS . body body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 98

state 48

    (58) stmt -> SOME .

    SCOLON          reduce using rule 58 (stmt -> SOME .)
    $end            reduce using rule 58 (stmt -> SOME .)
    RBRACKET        reduce using rule 58 (stmt -> SOME .)


state 49

    (59) stmt -> NONE . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 99

state 50

    (60) stmt -> LEFT . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 100

state 51

    (61) stmt -> RIGHT . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 101

state 52

    (62) stmt -> CONS .

    SCOLON          reduce using rule 62 (stmt -> CONS .)
    $end            reduce using rule 62 (stmt -> CONS .)
    RBRACKET        reduce using rule 62 (stmt -> CONS .)


state 53

    (63) stmt -> NIL . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 102

state 54

    (64) stmt -> NOT .

    SCOLON          reduce using rule 64 (stmt -> NOT .)
    $end            reduce using rule 64 (stmt -> NOT .)
    RBRACKET        reduce using rule 64 (stmt -> NOT .)


state 55

    (65) stmt -> EXEC .

    SCOLON          reduce using rule 65 (stmt -> EXEC .)
    $end            reduce using rule 65 (stmt -> EXEC .)
    RBRACKET        reduce using rule 65 (stmt -> EXEC .)


state 56

    (66) stmt -> STEPS_TO_QUOTA .

    SCOLON          reduce using rule 66 (stmt -> STEPS_TO_QUOTA .)
    $end            reduce using rule 66 (stmt -> STEPS_TO_QUOTA .)
    RBRACKET        reduce using rule 66 (stmt -> STEPS_TO_QUOTA .)


state 57

    (67) stmt -> NOW .

    SCOLON          reduce using rule 67 (stmt -> NOW .)
    $end            reduce using rule 67 (stmt -> NOW .)
    RBRACKET        reduce using rule 67 (stmt -> NOW .)


state 58

    (68) stmt -> CONTRACT . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 103

state 59

    (69) stmt -> HASH_KEY .

    SCOLON          reduce using rule 69 (stmt -> HASH_KEY .)
    $end            reduce using rule 69 (stmt -> HASH_KEY .)
    RBRACKET        reduce using rule 69 (stmt -> HASH_KEY .)


state 60

    (70) stmt -> BLAKE2B .

    SCOLON          reduce using rule 70 (stmt -> BLAKE2B .)
    $end            reduce using rule 70 (stmt -> BLAKE2B .)
    RBRACKET        reduce using rule 70 (stmt -> BLAKE2B .)


state 61

    (71) stmt -> SHA256 .

    SCOLON          reduce using rule 71 (stmt -> SHA256 .)
    $end            reduce using rule 71 (stmt -> SHA256 .)
    RBRACKET        reduce using rule 71 (stmt -> SHA256 .)


state 62

    (72) stmt -> SHA512 .

    SCOLON          reduce using rule 72 (stmt -> SHA512 .)
    $end            reduce using rule 72 (stmt -> SHA512 .)
    RBRACKET        reduce using rule 72 (stmt -> SHA512 .)


state 63

    (73) stmt -> CHECK_SIGNATURE .

    SCOLON          reduce using rule 73 (stmt -> CHECK_SIGNATURE .)
    $end            reduce using rule 73 (stmt -> CHECK_SIGNATURE .)
    RBRACKET        reduce using rule 73 (stmt -> CHECK_SIGNATURE .)


state 64

    (83) stmt -> DIP . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 104

state 65

    (84) stmt -> PUSH . type value
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 105

state 66

    (85) stmt -> ASSERT .

    SCOLON          reduce using rule 85 (stmt -> ASSERT .)
    $end            reduce using rule 85 (stmt -> ASSERT .)
    RBRACKET        reduce using rule 85 (stmt -> ASSERT .)


state 67

    (86) stmt -> ASSERT_EQ .

    SCOLON          reduce using rule 86 (stmt -> ASSERT_EQ .)
    $end            reduce using rule 86 (stmt -> ASSERT_EQ .)
    RBRACKET        reduce using rule 86 (stmt -> ASSERT_EQ .)


state 68

    (87) stmt -> ASSERT_NEQ .

    SCOLON          reduce using rule 87 (stmt -> ASSERT_NEQ .)
    $end            reduce using rule 87 (stmt -> ASSERT_NEQ .)
    RBRACKET        reduce using rule 87 (stmt -> ASSERT_NEQ .)


state 69

    (88) stmt -> ASSERT_LT .

    SCOLON          reduce using rule 88 (stmt -> ASSERT_LT .)
    $end            reduce using rule 88 (stmt -> ASSERT_LT .)
    RBRACKET        reduce using rule 88 (stmt -> ASSERT_LT .)


state 70

    (89) stmt -> ASSERT_LTE .

    SCOLON          reduce using rule 89 (stmt -> ASSERT_LTE .)
    $end            reduce using rule 89 (stmt -> ASSERT_LTE .)
    RBRACKET        reduce using rule 89 (stmt -> ASSERT_LTE .)


state 71

    (90) stmt -> ASSERT_GT .

    SCOLON          reduce using rule 90 (stmt -> ASSERT_GT .)
    $end            reduce using rule 90 (stmt -> ASSERT_GT .)
    RBRACKET        reduce using rule 90 (stmt -> ASSERT_GT .)


state 72

    (91) stmt -> ASSERT_GTE .

    SCOLON          reduce using rule 91 (stmt -> ASSERT_GTE .)
    $end            reduce using rule 91 (stmt -> ASSERT_GTE .)
    RBRACKET        reduce using rule 91 (stmt -> ASSERT_GTE .)


state 73

    (92) stmt -> FAILWITH .

    SCOLON          reduce using rule 92 (stmt -> FAILWITH .)
    $end            reduce using rule 92 (stmt -> FAILWITH .)
    RBRACKET        reduce using rule 92 (stmt -> FAILWITH .)


state 74

    (93) stmt -> FAIL .

    SCOLON          reduce using rule 93 (stmt -> FAIL .)
    $end            reduce using rule 93 (stmt -> FAIL .)
    RBRACKET        reduce using rule 93 (stmt -> FAIL .)


state 75

    (94) stmt -> PRINTER .

    SCOLON          reduce using rule 94 (stmt -> PRINTER .)
    $end            reduce using rule 94 (stmt -> PRINTER .)
    RBRACKET        reduce using rule 94 (stmt -> PRINTER .)


state 76

    (1) contract_run -> contract_decl code_decl .

    $end            reduce using rule 1 (contract_run -> contract_decl code_decl .)


state 77

    (4) code_decl -> CODE . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 106

state 78

    (3) contract_decl -> PARAMETER type . SCOLON STORAGE type SCOLON

    SCOLON          shift and go to state 107


state 79

    (74) type -> NAT .

    SCOLON          reduce using rule 74 (type -> NAT .)
    NAT             reduce using rule 74 (type -> NAT .)
    STRING          reduce using rule 74 (type -> NAT .)
    INT             reduce using rule 74 (type -> NAT .)
    BOOL            reduce using rule 74 (type -> NAT .)
    BYTES           reduce using rule 74 (type -> NAT .)
    OPERATION       reduce using rule 74 (type -> NAT .)
    ADDRESS         reduce using rule 74 (type -> NAT .)
    TIMESTAMP       reduce using rule 74 (type -> NAT .)
    LPARENS         reduce using rule 74 (type -> NAT .)
    $end            reduce using rule 74 (type -> NAT .)
    RBRACKET        reduce using rule 74 (type -> NAT .)
    NUMBER          reduce using rule 74 (type -> NAT .)
    TEXT            reduce using rule 74 (type -> NAT .)
    TRUE            reduce using rule 74 (type -> NAT .)
    FALSE           reduce using rule 74 (type -> NAT .)
    LBRACKET        reduce using rule 74 (type -> NAT .)
    RPARENS         reduce using rule 74 (type -> NAT .)


state 80

    (75) type -> STRING .

    SCOLON          reduce using rule 75 (type -> STRING .)
    NAT             reduce using rule 75 (type -> STRING .)
    STRING          reduce using rule 75 (type -> STRING .)
    INT             reduce using rule 75 (type -> STRING .)
    BOOL            reduce using rule 75 (type -> STRING .)
    BYTES           reduce using rule 75 (type -> STRING .)
    OPERATION       reduce using rule 75 (type -> STRING .)
    ADDRESS         reduce using rule 75 (type -> STRING .)
    TIMESTAMP       reduce using rule 75 (type -> STRING .)
    LPARENS         reduce using rule 75 (type -> STRING .)
    $end            reduce using rule 75 (type -> STRING .)
    RBRACKET        reduce using rule 75 (type -> STRING .)
    NUMBER          reduce using rule 75 (type -> STRING .)
    TEXT            reduce using rule 75 (type -> STRING .)
    TRUE            reduce using rule 75 (type -> STRING .)
    FALSE           reduce using rule 75 (type -> STRING .)
    LBRACKET        reduce using rule 75 (type -> STRING .)
    RPARENS         reduce using rule 75 (type -> STRING .)


state 81

    (76) type -> INT .

    SCOLON          reduce using rule 76 (type -> INT .)
    NAT             reduce using rule 76 (type -> INT .)
    STRING          reduce using rule 76 (type -> INT .)
    INT             reduce using rule 76 (type -> INT .)
    BOOL            reduce using rule 76 (type -> INT .)
    BYTES           reduce using rule 76 (type -> INT .)
    OPERATION       reduce using rule 76 (type -> INT .)
    ADDRESS         reduce using rule 76 (type -> INT .)
    TIMESTAMP       reduce using rule 76 (type -> INT .)
    LPARENS         reduce using rule 76 (type -> INT .)
    $end            reduce using rule 76 (type -> INT .)
    RBRACKET        reduce using rule 76 (type -> INT .)
    NUMBER          reduce using rule 76 (type -> INT .)
    TEXT            reduce using rule 76 (type -> INT .)
    TRUE            reduce using rule 76 (type -> INT .)
    FALSE           reduce using rule 76 (type -> INT .)
    LBRACKET        reduce using rule 76 (type -> INT .)
    RPARENS         reduce using rule 76 (type -> INT .)


state 82

    (77) type -> BOOL .

    SCOLON          reduce using rule 77 (type -> BOOL .)
    NAT             reduce using rule 77 (type -> BOOL .)
    STRING          reduce using rule 77 (type -> BOOL .)
    INT             reduce using rule 77 (type -> BOOL .)
    BOOL            reduce using rule 77 (type -> BOOL .)
    BYTES           reduce using rule 77 (type -> BOOL .)
    OPERATION       reduce using rule 77 (type -> BOOL .)
    ADDRESS         reduce using rule 77 (type -> BOOL .)
    TIMESTAMP       reduce using rule 77 (type -> BOOL .)
    LPARENS         reduce using rule 77 (type -> BOOL .)
    $end            reduce using rule 77 (type -> BOOL .)
    RBRACKET        reduce using rule 77 (type -> BOOL .)
    NUMBER          reduce using rule 77 (type -> BOOL .)
    TEXT            reduce using rule 77 (type -> BOOL .)
    TRUE            reduce using rule 77 (type -> BOOL .)
    FALSE           reduce using rule 77 (type -> BOOL .)
    LBRACKET        reduce using rule 77 (type -> BOOL .)
    RPARENS         reduce using rule 77 (type -> BOOL .)


state 83

    (78) type -> BYTES .

    SCOLON          reduce using rule 78 (type -> BYTES .)
    NAT             reduce using rule 78 (type -> BYTES .)
    STRING          reduce using rule 78 (type -> BYTES .)
    INT             reduce using rule 78 (type -> BYTES .)
    BOOL            reduce using rule 78 (type -> BYTES .)
    BYTES           reduce using rule 78 (type -> BYTES .)
    OPERATION       reduce using rule 78 (type -> BYTES .)
    ADDRESS         reduce using rule 78 (type -> BYTES .)
    TIMESTAMP       reduce using rule 78 (type -> BYTES .)
    LPARENS         reduce using rule 78 (type -> BYTES .)
    $end            reduce using rule 78 (type -> BYTES .)
    RBRACKET        reduce using rule 78 (type -> BYTES .)
    NUMBER          reduce using rule 78 (type -> BYTES .)
    TEXT            reduce using rule 78 (type -> BYTES .)
    TRUE            reduce using rule 78 (type -> BYTES .)
    FALSE           reduce using rule 78 (type -> BYTES .)
    LBRACKET        reduce using rule 78 (type -> BYTES .)
    RPARENS         reduce using rule 78 (type -> BYTES .)


state 84

    (79) type -> OPERATION .

    SCOLON          reduce using rule 79 (type -> OPERATION .)
    NAT             reduce using rule 79 (type -> OPERATION .)
    STRING          reduce using rule 79 (type -> OPERATION .)
    INT             reduce using rule 79 (type -> OPERATION .)
    BOOL            reduce using rule 79 (type -> OPERATION .)
    BYTES           reduce using rule 79 (type -> OPERATION .)
    OPERATION       reduce using rule 79 (type -> OPERATION .)
    ADDRESS         reduce using rule 79 (type -> OPERATION .)
    TIMESTAMP       reduce using rule 79 (type -> OPERATION .)
    LPARENS         reduce using rule 79 (type -> OPERATION .)
    $end            reduce using rule 79 (type -> OPERATION .)
    RBRACKET        reduce using rule 79 (type -> OPERATION .)
    NUMBER          reduce using rule 79 (type -> OPERATION .)
    TEXT            reduce using rule 79 (type -> OPERATION .)
    TRUE            reduce using rule 79 (type -> OPERATION .)
    FALSE           reduce using rule 79 (type -> OPERATION .)
    LBRACKET        reduce using rule 79 (type -> OPERATION .)
    RPARENS         reduce using rule 79 (type -> OPERATION .)


state 85

    (80) type -> ADDRESS .

    SCOLON          reduce using rule 80 (type -> ADDRESS .)
    NAT             reduce using rule 80 (type -> ADDRESS .)
    STRING          reduce using rule 80 (type -> ADDRESS .)
    INT             reduce using rule 80 (type -> ADDRESS .)
    BOOL            reduce using rule 80 (type -> ADDRESS .)
    BYTES           reduce using rule 80 (type -> ADDRESS .)
    OPERATION       reduce using rule 80 (type -> ADDRESS .)
    ADDRESS         reduce using rule 80 (type -> ADDRESS .)
    TIMESTAMP       reduce using rule 80 (type -> ADDRESS .)
    LPARENS         reduce using rule 80 (type -> ADDRESS .)
    $end            reduce using rule 80 (type -> ADDRESS .)
    RBRACKET        reduce using rule 80 (type -> ADDRESS .)
    NUMBER          reduce using rule 80 (type -> ADDRESS .)
    TEXT            reduce using rule 80 (type -> ADDRESS .)
    TRUE            reduce using rule 80 (type -> ADDRESS .)
    FALSE           reduce using rule 80 (type -> ADDRESS .)
    LBRACKET        reduce using rule 80 (type -> ADDRESS .)
    RPARENS         reduce using rule 80 (type -> ADDRESS .)


state 86

    (81) type -> TIMESTAMP .

    SCOLON          reduce using rule 81 (type -> TIMESTAMP .)
    NAT             reduce using rule 81 (type -> TIMESTAMP .)
    STRING          reduce using rule 81 (type -> TIMESTAMP .)
    INT             reduce using rule 81 (type -> TIMESTAMP .)
    BOOL            reduce using rule 81 (type -> TIMESTAMP .)
    BYTES           reduce using rule 81 (type -> TIMESTAMP .)
    OPERATION       reduce using rule 81 (type -> TIMESTAMP .)
    ADDRESS         reduce using rule 81 (type -> TIMESTAMP .)
    TIMESTAMP       reduce using rule 81 (type -> TIMESTAMP .)
    LPARENS         reduce using rule 81 (type -> TIMESTAMP .)
    $end            reduce using rule 81 (type -> TIMESTAMP .)
    RBRACKET        reduce using rule 81 (type -> TIMESTAMP .)
    NUMBER          reduce using rule 81 (type -> TIMESTAMP .)
    TEXT            reduce using rule 81 (type -> TIMESTAMP .)
    TRUE            reduce using rule 81 (type -> TIMESTAMP .)
    FALSE           reduce using rule 81 (type -> TIMESTAMP .)
    LBRACKET        reduce using rule 81 (type -> TIMESTAMP .)
    RPARENS         reduce using rule 81 (type -> TIMESTAMP .)


state 87

    (82) type -> LPARENS . LPAIR type type RPARENS

    LPAIR           shift and go to state 108


state 88

    (6) execution -> compound_statement SCOLON .
    (9) compound_statement -> compound_statement SCOLON . stmt
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_LEFT body body
    (56) stmt -> . IF_RIGHT body body
    (57) stmt -> . IF_CONS body body
    (58) stmt -> . SOME
    (59) stmt -> . NONE type
    (60) stmt -> . LEFT type
    (61) stmt -> . RIGHT type
    (62) stmt -> . CONS
    (63) stmt -> . NIL type
    (64) stmt -> . NOT
    (65) stmt -> . EXEC
    (66) stmt -> . STEPS_TO_QUOTA
    (67) stmt -> . NOW
    (68) stmt -> . CONTRACT type
    (69) stmt -> . HASH_KEY
    (70) stmt -> . BLAKE2B
    (71) stmt -> . SHA256
    (72) stmt -> . SHA512
    (73) stmt -> . CHECK_SIGNATURE
    (83) stmt -> . DIP body
    (84) stmt -> . PUSH type value
    (85) stmt -> . ASSERT
    (86) stmt -> . ASSERT_EQ
    (87) stmt -> . ASSERT_NEQ
    (88) stmt -> . ASSERT_LT
    (89) stmt -> . ASSERT_LTE
    (90) stmt -> . ASSERT_GT
    (91) stmt -> . ASSERT_GTE
    (92) stmt -> . FAILWITH
    (93) stmt -> . FAIL
    (94) stmt -> . PRINTER

    $end            reduce using rule 6 (execution -> compound_statement SCOLON .)
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_LEFT         shift and go to state 45
    IF_RIGHT        shift and go to state 46
    IF_CONS         shift and go to state 47
    SOME            shift and go to state 48
    NONE            shift and go to state 49
    LEFT            shift and go to state 50
    RIGHT           shift and go to state 51
    CONS            shift and go to state 52
    NIL             shift and go to state 53
    NOT             shift and go to state 54
    EXEC            shift and go to state 55
    STEPS_TO_QUOTA  shift and go to state 56
    NOW             shift and go to state 57
    CONTRACT        shift and go to state 58
    HASH_KEY        shift and go to state 59
    BLAKE2B         shift and go to state 60
    SHA256          shift and go to state 61
    SHA512          shift and go to state 62
    CHECK_SIGNATURE shift and go to state 63
    DIP             shift and go to state 64
    PUSH            shift and go to state 65
    ASSERT          shift and go to state 66
    ASSERT_EQ       shift and go to state 67
    ASSERT_NEQ      shift and go to state 68
    ASSERT_LT       shift and go to state 69
    ASSERT_LTE      shift and go to state 70
    ASSERT_GT       shift and go to state 71
    ASSERT_GTE      shift and go to state 72
    FAILWITH        shift and go to state 73
    FAIL            shift and go to state 74
    PRINTER         shift and go to state 75

    stmt                           shift and go to state 109

state 89

    (10) body -> LBRACKET compound_statement . SCOLON RBRACKET
    (11) body -> LBRACKET compound_statement . RBRACKET
    (9) compound_statement -> compound_statement . SCOLON stmt

    SCOLON          shift and go to state 110
    RBRACKET        shift and go to state 111


state 90

    (12) body -> LBRACKET RBRACKET .

    $end            reduce using rule 12 (body -> LBRACKET RBRACKET .)
    SCOLON          reduce using rule 12 (body -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 12 (body -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 12 (body -> LBRACKET RBRACKET .)


state 91

    (13) stmt -> LAMBDA type . type body
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 112

state 92

    (48) stmt -> EMPTY_SET type .

    SCOLON          reduce using rule 48 (stmt -> EMPTY_SET type .)
    $end            reduce using rule 48 (stmt -> EMPTY_SET type .)
    RBRACKET        reduce using rule 48 (stmt -> EMPTY_SET type .)


state 93

    (51) stmt -> EMPTY_MAP type . type
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 113

state 94

    (52) stmt -> MAP body .

    SCOLON          reduce using rule 52 (stmt -> MAP body .)
    $end            reduce using rule 52 (stmt -> MAP body .)
    RBRACKET        reduce using rule 52 (stmt -> MAP body .)


state 95

    (53) stmt -> ITER body .

    SCOLON          reduce using rule 53 (stmt -> ITER body .)
    $end            reduce using rule 53 (stmt -> ITER body .)
    RBRACKET        reduce using rule 53 (stmt -> ITER body .)


state 96

    (55) stmt -> IF_LEFT body . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 114

state 97

    (56) stmt -> IF_RIGHT body . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 115

state 98

    (57) stmt -> IF_CONS body . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 116

state 99

    (59) stmt -> NONE type .

    SCOLON          reduce using rule 59 (stmt -> NONE type .)
    $end            reduce using rule 59 (stmt -> NONE type .)
    RBRACKET        reduce using rule 59 (stmt -> NONE type .)


state 100

    (60) stmt -> LEFT type .

    SCOLON          reduce using rule 60 (stmt -> LEFT type .)
    $end            reduce using rule 60 (stmt -> LEFT type .)
    RBRACKET        reduce using rule 60 (stmt -> LEFT type .)


state 101

    (61) stmt -> RIGHT type .

    SCOLON          reduce using rule 61 (stmt -> RIGHT type .)
    $end            reduce using rule 61 (stmt -> RIGHT type .)
    RBRACKET        reduce using rule 61 (stmt -> RIGHT type .)


state 102

    (63) stmt -> NIL type .

    SCOLON          reduce using rule 63 (stmt -> NIL type .)
    $end            reduce using rule 63 (stmt -> NIL type .)
    RBRACKET        reduce using rule 63 (stmt -> NIL type .)


state 103

    (68) stmt -> CONTRACT type .

    SCOLON          reduce using rule 68 (stmt -> CONTRACT type .)
    $end            reduce using rule 68 (stmt -> CONTRACT type .)
    RBRACKET        reduce using rule 68 (stmt -> CONTRACT type .)


state 104

    (83) stmt -> DIP body .

    SCOLON          reduce using rule 83 (stmt -> DIP body .)
    $end            reduce using rule 83 (stmt -> DIP body .)
    RBRACKET        reduce using rule 83 (stmt -> DIP body .)


state 105

    (84) stmt -> PUSH type . value
    (20) value -> . NUMBER
    (21) value -> . bool
    (22) value -> . TEXT
    (23) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (18) bool -> . TRUE
    (19) bool -> . FALSE

    NUMBER          shift and go to state 118
    TEXT            shift and go to state 120
    LPARENS         shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123

    value                          shift and go to state 117
    bool                           shift and go to state 119

state 106

    (4) code_decl -> CODE body .

    $end            reduce using rule 4 (code_decl -> CODE body .)


state 107

    (3) contract_decl -> PARAMETER type SCOLON . STORAGE type SCOLON

    STORAGE         shift and go to state 124


state 108

    (82) type -> LPARENS LPAIR . type type RPARENS
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 125

state 109

    (9) compound_statement -> compound_statement SCOLON stmt .

    SCOLON          reduce using rule 9 (compound_statement -> compound_statement SCOLON stmt .)
    $end            reduce using rule 9 (compound_statement -> compound_statement SCOLON stmt .)
    RBRACKET        reduce using rule 9 (compound_statement -> compound_statement SCOLON stmt .)


state 110

    (10) body -> LBRACKET compound_statement SCOLON . RBRACKET
    (9) compound_statement -> compound_statement SCOLON . stmt
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_LEFT body body
    (56) stmt -> . IF_RIGHT body body
    (57) stmt -> . IF_CONS body body
    (58) stmt -> . SOME
    (59) stmt -> . NONE type
    (60) stmt -> . LEFT type
    (61) stmt -> . RIGHT type
    (62) stmt -> . CONS
    (63) stmt -> . NIL type
    (64) stmt -> . NOT
    (65) stmt -> . EXEC
    (66) stmt -> . STEPS_TO_QUOTA
    (67) stmt -> . NOW
    (68) stmt -> . CONTRACT type
    (69) stmt -> . HASH_KEY
    (70) stmt -> . BLAKE2B
    (71) stmt -> . SHA256
    (72) stmt -> . SHA512
    (73) stmt -> . CHECK_SIGNATURE
    (83) stmt -> . DIP body
    (84) stmt -> . PUSH type value
    (85) stmt -> . ASSERT
    (86) stmt -> . ASSERT_EQ
    (87) stmt -> . ASSERT_NEQ
    (88) stmt -> . ASSERT_LT
    (89) stmt -> . ASSERT_LTE
    (90) stmt -> . ASSERT_GT
    (91) stmt -> . ASSERT_GTE
    (92) stmt -> . FAILWITH
    (93) stmt -> . FAIL
    (94) stmt -> . PRINTER

    RBRACKET        shift and go to state 126
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_LEFT         shift and go to state 45
    IF_RIGHT        shift and go to state 46
    IF_CONS         shift and go to state 47
    SOME            shift and go to state 48
    NONE            shift and go to state 49
    LEFT            shift and go to state 50
    RIGHT           shift and go to state 51
    CONS            shift and go to state 52
    NIL             shift and go to state 53
    NOT             shift and go to state 54
    EXEC            shift and go to state 55
    STEPS_TO_QUOTA  shift and go to state 56
    NOW             shift and go to state 57
    CONTRACT        shift and go to state 58
    HASH_KEY        shift and go to state 59
    BLAKE2B         shift and go to state 60
    SHA256          shift and go to state 61
    SHA512          shift and go to state 62
    CHECK_SIGNATURE shift and go to state 63
    DIP             shift and go to state 64
    PUSH            shift and go to state 65
    ASSERT          shift and go to state 66
    ASSERT_EQ       shift and go to state 67
    ASSERT_NEQ      shift and go to state 68
    ASSERT_LT       shift and go to state 69
    ASSERT_LTE      shift and go to state 70
    ASSERT_GT       shift and go to state 71
    ASSERT_GTE      shift and go to state 72
    FAILWITH        shift and go to state 73
    FAIL            shift and go to state 74
    PRINTER         shift and go to state 75

    stmt                           shift and go to state 109

state 111

    (11) body -> LBRACKET compound_statement RBRACKET .

    $end            reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)
    SCOLON          reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)
    RBRACKET        reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)
    LBRACKET        reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)


state 112

    (13) stmt -> LAMBDA type type . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 127

state 113

    (51) stmt -> EMPTY_MAP type type .

    SCOLON          reduce using rule 51 (stmt -> EMPTY_MAP type type .)
    $end            reduce using rule 51 (stmt -> EMPTY_MAP type type .)
    RBRACKET        reduce using rule 51 (stmt -> EMPTY_MAP type type .)


state 114

    (55) stmt -> IF_LEFT body body .

    SCOLON          reduce using rule 55 (stmt -> IF_LEFT body body .)
    $end            reduce using rule 55 (stmt -> IF_LEFT body body .)
    RBRACKET        reduce using rule 55 (stmt -> IF_LEFT body body .)


state 115

    (56) stmt -> IF_RIGHT body body .

    SCOLON          reduce using rule 56 (stmt -> IF_RIGHT body body .)
    $end            reduce using rule 56 (stmt -> IF_RIGHT body body .)
    RBRACKET        reduce using rule 56 (stmt -> IF_RIGHT body body .)


state 116

    (57) stmt -> IF_CONS body body .

    SCOLON          reduce using rule 57 (stmt -> IF_CONS body body .)
    $end            reduce using rule 57 (stmt -> IF_CONS body body .)
    RBRACKET        reduce using rule 57 (stmt -> IF_CONS body body .)


state 117

    (84) stmt -> PUSH type value .

    SCOLON          reduce using rule 84 (stmt -> PUSH type value .)
    $end            reduce using rule 84 (stmt -> PUSH type value .)
    RBRACKET        reduce using rule 84 (stmt -> PUSH type value .)


state 118

    (20) value -> NUMBER .

    SCOLON          reduce using rule 20 (value -> NUMBER .)
    $end            reduce using rule 20 (value -> NUMBER .)
    RBRACKET        reduce using rule 20 (value -> NUMBER .)
    NUMBER          reduce using rule 20 (value -> NUMBER .)
    TEXT            reduce using rule 20 (value -> NUMBER .)
    LPARENS         reduce using rule 20 (value -> NUMBER .)
    TRUE            reduce using rule 20 (value -> NUMBER .)
    FALSE           reduce using rule 20 (value -> NUMBER .)
    RPARENS         reduce using rule 20 (value -> NUMBER .)


state 119

    (21) value -> bool .

    SCOLON          reduce using rule 21 (value -> bool .)
    $end            reduce using rule 21 (value -> bool .)
    RBRACKET        reduce using rule 21 (value -> bool .)
    NUMBER          reduce using rule 21 (value -> bool .)
    TEXT            reduce using rule 21 (value -> bool .)
    LPARENS         reduce using rule 21 (value -> bool .)
    TRUE            reduce using rule 21 (value -> bool .)
    FALSE           reduce using rule 21 (value -> bool .)
    RPARENS         reduce using rule 21 (value -> bool .)


state 120

    (22) value -> TEXT .

    SCOLON          reduce using rule 22 (value -> TEXT .)
    $end            reduce using rule 22 (value -> TEXT .)
    RBRACKET        reduce using rule 22 (value -> TEXT .)
    NUMBER          reduce using rule 22 (value -> TEXT .)
    TEXT            reduce using rule 22 (value -> TEXT .)
    LPARENS         reduce using rule 22 (value -> TEXT .)
    TRUE            reduce using rule 22 (value -> TEXT .)
    FALSE           reduce using rule 22 (value -> TEXT .)
    RPARENS         reduce using rule 22 (value -> TEXT .)


state 121

    (23) value -> LPARENS . PAIR_CONSTRUCTOR value value RPARENS

    PAIR_CONSTRUCTOR shift and go to state 128


state 122

    (18) bool -> TRUE .

    SCOLON          reduce using rule 18 (bool -> TRUE .)
    $end            reduce using rule 18 (bool -> TRUE .)
    RBRACKET        reduce using rule 18 (bool -> TRUE .)
    NUMBER          reduce using rule 18 (bool -> TRUE .)
    TEXT            reduce using rule 18 (bool -> TRUE .)
    LPARENS         reduce using rule 18 (bool -> TRUE .)
    TRUE            reduce using rule 18 (bool -> TRUE .)
    FALSE           reduce using rule 18 (bool -> TRUE .)
    RPARENS         reduce using rule 18 (bool -> TRUE .)


state 123

    (19) bool -> FALSE .

    SCOLON          reduce using rule 19 (bool -> FALSE .)
    $end            reduce using rule 19 (bool -> FALSE .)
    RBRACKET        reduce using rule 19 (bool -> FALSE .)
    NUMBER          reduce using rule 19 (bool -> FALSE .)
    TEXT            reduce using rule 19 (bool -> FALSE .)
    LPARENS         reduce using rule 19 (bool -> FALSE .)
    TRUE            reduce using rule 19 (bool -> FALSE .)
    FALSE           reduce using rule 19 (bool -> FALSE .)
    RPARENS         reduce using rule 19 (bool -> FALSE .)


state 124

    (3) contract_decl -> PARAMETER type SCOLON STORAGE . type SCOLON
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 129

state 125

    (82) type -> LPARENS LPAIR type . type RPARENS
    (74) type -> . NAT
    (75) type -> . STRING
    (76) type -> . INT
    (77) type -> . BOOL
    (78) type -> . BYTES
    (79) type -> . OPERATION
    (80) type -> . ADDRESS
    (81) type -> . TIMESTAMP
    (82) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 79
    STRING          shift and go to state 80
    INT             shift and go to state 81
    BOOL            shift and go to state 82
    BYTES           shift and go to state 83
    OPERATION       shift and go to state 84
    ADDRESS         shift and go to state 85
    TIMESTAMP       shift and go to state 86
    LPARENS         shift and go to state 87

    type                           shift and go to state 130

state 126

    (10) body -> LBRACKET compound_statement SCOLON RBRACKET .

    $end            reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    SCOLON          reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    RBRACKET        reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    LBRACKET        reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)


state 127

    (13) stmt -> LAMBDA type type body .

    SCOLON          reduce using rule 13 (stmt -> LAMBDA type type body .)
    $end            reduce using rule 13 (stmt -> LAMBDA type type body .)
    RBRACKET        reduce using rule 13 (stmt -> LAMBDA type type body .)


state 128

    (23) value -> LPARENS PAIR_CONSTRUCTOR . value value RPARENS
    (20) value -> . NUMBER
    (21) value -> . bool
    (22) value -> . TEXT
    (23) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (18) bool -> . TRUE
    (19) bool -> . FALSE

    NUMBER          shift and go to state 118
    TEXT            shift and go to state 120
    LPARENS         shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123

    value                          shift and go to state 131
    bool                           shift and go to state 119

state 129

    (3) contract_decl -> PARAMETER type SCOLON STORAGE type . SCOLON

    SCOLON          shift and go to state 132


state 130

    (82) type -> LPARENS LPAIR type type . RPARENS

    RPARENS         shift and go to state 133


state 131

    (23) value -> LPARENS PAIR_CONSTRUCTOR value . value RPARENS
    (20) value -> . NUMBER
    (21) value -> . bool
    (22) value -> . TEXT
    (23) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (18) bool -> . TRUE
    (19) bool -> . FALSE

    NUMBER          shift and go to state 118
    TEXT            shift and go to state 120
    LPARENS         shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123

    value                          shift and go to state 134
    bool                           shift and go to state 119

state 132

    (3) contract_decl -> PARAMETER type SCOLON STORAGE type SCOLON .

    CODE            reduce using rule 3 (contract_decl -> PARAMETER type SCOLON STORAGE type SCOLON .)


state 133

    (82) type -> LPARENS LPAIR type type RPARENS .

    SCOLON          reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    NAT             reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    STRING          reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    INT             reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    BOOL            reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    BYTES           reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    OPERATION       reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    ADDRESS         reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    TIMESTAMP       reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    LPARENS         reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    $end            reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    RBRACKET        reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    NUMBER          reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    TEXT            reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    TRUE            reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    FALSE           reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    LBRACKET        reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)
    RPARENS         reduce using rule 82 (type -> LPARENS LPAIR type type RPARENS .)


state 134

    (23) value -> LPARENS PAIR_CONSTRUCTOR value value . RPARENS

    RPARENS         shift and go to state 135


state 135

    (23) value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .

    SCOLON          reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    $end            reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RBRACKET        reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    NUMBER          reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TEXT            reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    LPARENS         reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TRUE            reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    FALSE           reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RPARENS         reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)

