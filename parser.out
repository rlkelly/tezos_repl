Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EMPTY_MAP
    GET
    LBRACKET
    RBRACKET

Grammar

Rule 0     S' -> statement
Rule 1     statement -> DROP
Rule 2     statement -> DUP
Rule 3     statement -> SWAP
Rule 4     statement -> UNIT
Rule 5     bool -> TRUE
Rule 6     bool -> FALSE
Rule 7     value -> NUMBER
Rule 8     value -> bool
Rule 9     value -> TEXT
Rule 10    statement -> EQ
Rule 11    statement -> NEQ
Rule 12    statement -> LT
Rule 13    statement -> GT
Rule 14    statement -> LE
Rule 15    statement -> GE
Rule 16    statement -> OR
Rule 17    statement -> AND
Rule 18    statement -> XOR
Rule 19    statement -> COMPARE
Rule 20    statement -> NEG
Rule 21    statement -> ABS
Rule 22    statement -> ADD
Rule 23    statement -> SUB
Rule 24    statement -> MUL
Rule 25    statement -> EDIV
Rule 26    statement -> LSL
Rule 27    statement -> LSR
Rule 28    statement -> CONCAT
Rule 29    statement -> SIZE
Rule 30    statement -> SLICE
Rule 31    statement -> PAIR
Rule 32    statement -> CAR
Rule 33    statement -> CDR
Rule 34    statement -> EMPTY_SET TYPE
Rule 35    statement -> MEM
Rule 36    statement -> UPDATE
Rule 37    statement -> SOME
Rule 38    statement -> NONE TYPE
Rule 39    statement -> LEFT LPARENS TYPE TYPE RPARENS
Rule 40    statement -> RIGHT LPARENS TYPE TYPE RPARENS
Rule 41    statement -> CONS
Rule 42    statement -> NIL TYPE
Rule 43    statement -> NOT
Rule 44    TYPE -> NAT
Rule 45    TYPE -> STRING
Rule 46    TYPE -> INT
Rule 47    TYPE -> BOOL
Rule 48    TYPE -> BYTES
Rule 49    statement -> PUSH TYPE value
Rule 50    statement -> FAILWITH

Terminals, with rules where they appear

ABS                  : 21
ADD                  : 22
AND                  : 17
BOOL                 : 47
BYTES                : 48
CAR                  : 32
CDR                  : 33
COMPARE              : 19
CONCAT               : 28
CONS                 : 41
DROP                 : 1
DUP                  : 2
EDIV                 : 25
EMPTY_MAP            : 
EMPTY_SET            : 34
EQ                   : 10
FAILWITH             : 50
FALSE                : 6
GE                   : 15
GET                  : 
GT                   : 13
INT                  : 46
LBRACKET             : 
LE                   : 14
LEFT                 : 39
LPARENS              : 39 40
LSL                  : 26
LSR                  : 27
LT                   : 12
MEM                  : 35
MUL                  : 24
NAT                  : 44
NEG                  : 20
NEQ                  : 11
NIL                  : 42
NONE                 : 38
NOT                  : 43
NUMBER               : 7
OR                   : 16
PAIR                 : 31
PUSH                 : 49
RBRACKET             : 
RIGHT                : 40
RPARENS              : 39 40
SIZE                 : 29
SLICE                : 30
SOME                 : 37
STRING               : 45
SUB                  : 23
SWAP                 : 3
TEXT                 : 9
TRUE                 : 5
UNIT                 : 4
UPDATE               : 36
XOR                  : 18
error                : 

Nonterminals, with rules where they appear

TYPE                 : 34 38 39 39 40 40 42 49
bool                 : 8
statement            : 0
value                : 49

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . DROP
    (2) statement -> . DUP
    (3) statement -> . SWAP
    (4) statement -> . UNIT
    (10) statement -> . EQ
    (11) statement -> . NEQ
    (12) statement -> . LT
    (13) statement -> . GT
    (14) statement -> . LE
    (15) statement -> . GE
    (16) statement -> . OR
    (17) statement -> . AND
    (18) statement -> . XOR
    (19) statement -> . COMPARE
    (20) statement -> . NEG
    (21) statement -> . ABS
    (22) statement -> . ADD
    (23) statement -> . SUB
    (24) statement -> . MUL
    (25) statement -> . EDIV
    (26) statement -> . LSL
    (27) statement -> . LSR
    (28) statement -> . CONCAT
    (29) statement -> . SIZE
    (30) statement -> . SLICE
    (31) statement -> . PAIR
    (32) statement -> . CAR
    (33) statement -> . CDR
    (34) statement -> . EMPTY_SET TYPE
    (35) statement -> . MEM
    (36) statement -> . UPDATE
    (37) statement -> . SOME
    (38) statement -> . NONE TYPE
    (39) statement -> . LEFT LPARENS TYPE TYPE RPARENS
    (40) statement -> . RIGHT LPARENS TYPE TYPE RPARENS
    (41) statement -> . CONS
    (42) statement -> . NIL TYPE
    (43) statement -> . NOT
    (49) statement -> . PUSH TYPE value
    (50) statement -> . FAILWITH

    DROP            shift and go to state 2
    DUP             shift and go to state 3
    SWAP            shift and go to state 4
    UNIT            shift and go to state 5
    EQ              shift and go to state 6
    NEQ             shift and go to state 7
    LT              shift and go to state 8
    GT              shift and go to state 9
    LE              shift and go to state 10
    GE              shift and go to state 11
    OR              shift and go to state 12
    AND             shift and go to state 13
    XOR             shift and go to state 14
    COMPARE         shift and go to state 15
    NEG             shift and go to state 16
    ABS             shift and go to state 17
    ADD             shift and go to state 18
    SUB             shift and go to state 19
    MUL             shift and go to state 20
    EDIV            shift and go to state 21
    LSL             shift and go to state 22
    LSR             shift and go to state 23
    CONCAT          shift and go to state 24
    SIZE            shift and go to state 25
    SLICE           shift and go to state 26
    PAIR            shift and go to state 27
    CAR             shift and go to state 28
    CDR             shift and go to state 29
    EMPTY_SET       shift and go to state 30
    MEM             shift and go to state 31
    UPDATE          shift and go to state 32
    SOME            shift and go to state 33
    NONE            shift and go to state 34
    LEFT            shift and go to state 35
    RIGHT           shift and go to state 36
    CONS            shift and go to state 37
    NIL             shift and go to state 38
    NOT             shift and go to state 39
    PUSH            shift and go to state 40
    FAILWITH        shift and go to state 41

    statement                      shift and go to state 1

state 1

    (0) S' -> statement .



state 2

    (1) statement -> DROP .

    $end            reduce using rule 1 (statement -> DROP .)


state 3

    (2) statement -> DUP .

    $end            reduce using rule 2 (statement -> DUP .)


state 4

    (3) statement -> SWAP .

    $end            reduce using rule 3 (statement -> SWAP .)


state 5

    (4) statement -> UNIT .

    $end            reduce using rule 4 (statement -> UNIT .)


state 6

    (10) statement -> EQ .

    $end            reduce using rule 10 (statement -> EQ .)


state 7

    (11) statement -> NEQ .

    $end            reduce using rule 11 (statement -> NEQ .)


state 8

    (12) statement -> LT .

    $end            reduce using rule 12 (statement -> LT .)


state 9

    (13) statement -> GT .

    $end            reduce using rule 13 (statement -> GT .)


state 10

    (14) statement -> LE .

    $end            reduce using rule 14 (statement -> LE .)


state 11

    (15) statement -> GE .

    $end            reduce using rule 15 (statement -> GE .)


state 12

    (16) statement -> OR .

    $end            reduce using rule 16 (statement -> OR .)


state 13

    (17) statement -> AND .

    $end            reduce using rule 17 (statement -> AND .)


state 14

    (18) statement -> XOR .

    $end            reduce using rule 18 (statement -> XOR .)


state 15

    (19) statement -> COMPARE .

    $end            reduce using rule 19 (statement -> COMPARE .)


state 16

    (20) statement -> NEG .

    $end            reduce using rule 20 (statement -> NEG .)


state 17

    (21) statement -> ABS .

    $end            reduce using rule 21 (statement -> ABS .)


state 18

    (22) statement -> ADD .

    $end            reduce using rule 22 (statement -> ADD .)


state 19

    (23) statement -> SUB .

    $end            reduce using rule 23 (statement -> SUB .)


state 20

    (24) statement -> MUL .

    $end            reduce using rule 24 (statement -> MUL .)


state 21

    (25) statement -> EDIV .

    $end            reduce using rule 25 (statement -> EDIV .)


state 22

    (26) statement -> LSL .

    $end            reduce using rule 26 (statement -> LSL .)


state 23

    (27) statement -> LSR .

    $end            reduce using rule 27 (statement -> LSR .)


state 24

    (28) statement -> CONCAT .

    $end            reduce using rule 28 (statement -> CONCAT .)


state 25

    (29) statement -> SIZE .

    $end            reduce using rule 29 (statement -> SIZE .)


state 26

    (30) statement -> SLICE .

    $end            reduce using rule 30 (statement -> SLICE .)


state 27

    (31) statement -> PAIR .

    $end            reduce using rule 31 (statement -> PAIR .)


state 28

    (32) statement -> CAR .

    $end            reduce using rule 32 (statement -> CAR .)


state 29

    (33) statement -> CDR .

    $end            reduce using rule 33 (statement -> CDR .)


state 30

    (34) statement -> EMPTY_SET . TYPE
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 42

state 31

    (35) statement -> MEM .

    $end            reduce using rule 35 (statement -> MEM .)


state 32

    (36) statement -> UPDATE .

    $end            reduce using rule 36 (statement -> UPDATE .)


state 33

    (37) statement -> SOME .

    $end            reduce using rule 37 (statement -> SOME .)


state 34

    (38) statement -> NONE . TYPE
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 48

state 35

    (39) statement -> LEFT . LPARENS TYPE TYPE RPARENS

    LPARENS         shift and go to state 49


state 36

    (40) statement -> RIGHT . LPARENS TYPE TYPE RPARENS

    LPARENS         shift and go to state 50


state 37

    (41) statement -> CONS .

    $end            reduce using rule 41 (statement -> CONS .)


state 38

    (42) statement -> NIL . TYPE
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 51

state 39

    (43) statement -> NOT .

    $end            reduce using rule 43 (statement -> NOT .)


state 40

    (49) statement -> PUSH . TYPE value
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 52

state 41

    (50) statement -> FAILWITH .

    $end            reduce using rule 50 (statement -> FAILWITH .)


state 42

    (34) statement -> EMPTY_SET TYPE .

    $end            reduce using rule 34 (statement -> EMPTY_SET TYPE .)


state 43

    (44) TYPE -> NAT .

    $end            reduce using rule 44 (TYPE -> NAT .)
    NUMBER          reduce using rule 44 (TYPE -> NAT .)
    TEXT            reduce using rule 44 (TYPE -> NAT .)
    TRUE            reduce using rule 44 (TYPE -> NAT .)
    FALSE           reduce using rule 44 (TYPE -> NAT .)
    NAT             reduce using rule 44 (TYPE -> NAT .)
    STRING          reduce using rule 44 (TYPE -> NAT .)
    INT             reduce using rule 44 (TYPE -> NAT .)
    BOOL            reduce using rule 44 (TYPE -> NAT .)
    BYTES           reduce using rule 44 (TYPE -> NAT .)
    RPARENS         reduce using rule 44 (TYPE -> NAT .)


state 44

    (45) TYPE -> STRING .

    $end            reduce using rule 45 (TYPE -> STRING .)
    NUMBER          reduce using rule 45 (TYPE -> STRING .)
    TEXT            reduce using rule 45 (TYPE -> STRING .)
    TRUE            reduce using rule 45 (TYPE -> STRING .)
    FALSE           reduce using rule 45 (TYPE -> STRING .)
    NAT             reduce using rule 45 (TYPE -> STRING .)
    STRING          reduce using rule 45 (TYPE -> STRING .)
    INT             reduce using rule 45 (TYPE -> STRING .)
    BOOL            reduce using rule 45 (TYPE -> STRING .)
    BYTES           reduce using rule 45 (TYPE -> STRING .)
    RPARENS         reduce using rule 45 (TYPE -> STRING .)


state 45

    (46) TYPE -> INT .

    $end            reduce using rule 46 (TYPE -> INT .)
    NUMBER          reduce using rule 46 (TYPE -> INT .)
    TEXT            reduce using rule 46 (TYPE -> INT .)
    TRUE            reduce using rule 46 (TYPE -> INT .)
    FALSE           reduce using rule 46 (TYPE -> INT .)
    NAT             reduce using rule 46 (TYPE -> INT .)
    STRING          reduce using rule 46 (TYPE -> INT .)
    INT             reduce using rule 46 (TYPE -> INT .)
    BOOL            reduce using rule 46 (TYPE -> INT .)
    BYTES           reduce using rule 46 (TYPE -> INT .)
    RPARENS         reduce using rule 46 (TYPE -> INT .)


state 46

    (47) TYPE -> BOOL .

    $end            reduce using rule 47 (TYPE -> BOOL .)
    NUMBER          reduce using rule 47 (TYPE -> BOOL .)
    TEXT            reduce using rule 47 (TYPE -> BOOL .)
    TRUE            reduce using rule 47 (TYPE -> BOOL .)
    FALSE           reduce using rule 47 (TYPE -> BOOL .)
    NAT             reduce using rule 47 (TYPE -> BOOL .)
    STRING          reduce using rule 47 (TYPE -> BOOL .)
    INT             reduce using rule 47 (TYPE -> BOOL .)
    BOOL            reduce using rule 47 (TYPE -> BOOL .)
    BYTES           reduce using rule 47 (TYPE -> BOOL .)
    RPARENS         reduce using rule 47 (TYPE -> BOOL .)


state 47

    (48) TYPE -> BYTES .

    $end            reduce using rule 48 (TYPE -> BYTES .)
    NUMBER          reduce using rule 48 (TYPE -> BYTES .)
    TEXT            reduce using rule 48 (TYPE -> BYTES .)
    TRUE            reduce using rule 48 (TYPE -> BYTES .)
    FALSE           reduce using rule 48 (TYPE -> BYTES .)
    NAT             reduce using rule 48 (TYPE -> BYTES .)
    STRING          reduce using rule 48 (TYPE -> BYTES .)
    INT             reduce using rule 48 (TYPE -> BYTES .)
    BOOL            reduce using rule 48 (TYPE -> BYTES .)
    BYTES           reduce using rule 48 (TYPE -> BYTES .)
    RPARENS         reduce using rule 48 (TYPE -> BYTES .)


state 48

    (38) statement -> NONE TYPE .

    $end            reduce using rule 38 (statement -> NONE TYPE .)


state 49

    (39) statement -> LEFT LPARENS . TYPE TYPE RPARENS
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 53

state 50

    (40) statement -> RIGHT LPARENS . TYPE TYPE RPARENS
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 54

state 51

    (42) statement -> NIL TYPE .

    $end            reduce using rule 42 (statement -> NIL TYPE .)


state 52

    (49) statement -> PUSH TYPE . value
    (7) value -> . NUMBER
    (8) value -> . bool
    (9) value -> . TEXT
    (5) bool -> . TRUE
    (6) bool -> . FALSE

    NUMBER          shift and go to state 56
    TEXT            shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    value                          shift and go to state 55
    bool                           shift and go to state 57

state 53

    (39) statement -> LEFT LPARENS TYPE . TYPE RPARENS
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 61

state 54

    (40) statement -> RIGHT LPARENS TYPE . TYPE RPARENS
    (44) TYPE -> . NAT
    (45) TYPE -> . STRING
    (46) TYPE -> . INT
    (47) TYPE -> . BOOL
    (48) TYPE -> . BYTES

    NAT             shift and go to state 43
    STRING          shift and go to state 44
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    BYTES           shift and go to state 47

    TYPE                           shift and go to state 62

state 55

    (49) statement -> PUSH TYPE value .

    $end            reduce using rule 49 (statement -> PUSH TYPE value .)


state 56

    (7) value -> NUMBER .

    $end            reduce using rule 7 (value -> NUMBER .)


state 57

    (8) value -> bool .

    $end            reduce using rule 8 (value -> bool .)


state 58

    (9) value -> TEXT .

    $end            reduce using rule 9 (value -> TEXT .)


state 59

    (5) bool -> TRUE .

    $end            reduce using rule 5 (bool -> TRUE .)


state 60

    (6) bool -> FALSE .

    $end            reduce using rule 6 (bool -> FALSE .)


state 61

    (39) statement -> LEFT LPARENS TYPE TYPE . RPARENS

    RPARENS         shift and go to state 63


state 62

    (40) statement -> RIGHT LPARENS TYPE TYPE . RPARENS

    RPARENS         shift and go to state 64


state 63

    (39) statement -> LEFT LPARENS TYPE TYPE RPARENS .

    $end            reduce using rule 39 (statement -> LEFT LPARENS TYPE TYPE RPARENS .)


state 64

    (40) statement -> RIGHT LPARENS TYPE TYPE RPARENS .

    $end            reduce using rule 40 (statement -> RIGHT LPARENS TYPE TYPE RPARENS .)

