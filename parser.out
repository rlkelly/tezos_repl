Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MUTEZ
    TIMESTAMP

Grammar

Rule 0     S' -> execution
Rule 1     execution -> compound_statement
Rule 2     execution -> compound_statement SCOLON
Rule 3     execution -> body
Rule 4     compound_statement -> stmt
Rule 5     compound_statement -> compound_statement SCOLON stmt
Rule 6     body -> LBRACKET compound_statement SCOLON RBRACKET
Rule 7     body -> LBRACKET compound_statement RBRACKET
Rule 8     body -> LBRACKET RBRACKET
Rule 9     stmt -> LAMBDA type type body
Rule 10    stmt -> DROP
Rule 11    stmt -> DUP
Rule 12    stmt -> SWAP
Rule 13    stmt -> UNIT
Rule 14    bool -> TRUE
Rule 15    bool -> FALSE
Rule 16    value -> NUMBER
Rule 17    value -> bool
Rule 18    value -> TEXT
Rule 19    value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS
Rule 20    stmt -> EQ
Rule 21    stmt -> NEQ
Rule 22    stmt -> LT
Rule 23    stmt -> GT
Rule 24    stmt -> LE
Rule 25    stmt -> GE
Rule 26    stmt -> OR
Rule 27    stmt -> AND
Rule 28    stmt -> XOR
Rule 29    stmt -> COMPARE
Rule 30    stmt -> NEG
Rule 31    stmt -> ABS
Rule 32    stmt -> ADD
Rule 33    stmt -> SUB
Rule 34    stmt -> MUL
Rule 35    stmt -> EDIV
Rule 36    stmt -> LSL
Rule 37    stmt -> LSR
Rule 38    stmt -> SIZE
Rule 39    stmt -> CONCAT
Rule 40    stmt -> SLICE
Rule 41    stmt -> PAIR
Rule 42    stmt -> CAR
Rule 43    stmt -> CDR
Rule 44    stmt -> EMPTY_SET type
Rule 45    stmt -> MEM
Rule 46    stmt -> UPDATE
Rule 47    stmt -> EMPTY_MAP type type
Rule 48    stmt -> MAP body
Rule 49    stmt -> ITER body
Rule 50    stmt -> GET
Rule 51    stmt -> IF_CONS body body
Rule 52    stmt -> SOME
Rule 53    stmt -> NONE type
Rule 54    stmt -> LEFT type
Rule 55    stmt -> RIGHT type
Rule 56    stmt -> CONS
Rule 57    stmt -> NIL type
Rule 58    stmt -> NOT
Rule 59    stmt -> EXEC
Rule 60    stmt -> STEPS_TO_QUOTA
Rule 61    stmt -> NOW
Rule 62    stmt -> CONTRACT type
Rule 63    type -> NAT
Rule 64    type -> STRING
Rule 65    type -> INT
Rule 66    type -> BOOL
Rule 67    type -> BYTES
Rule 68    type -> OPERATION
Rule 69    type -> ADDRESS
Rule 70    type -> LPARENS LPAIR type type RPARENS
Rule 71    stmt -> DIP body
Rule 72    stmt -> PUSH type value
Rule 73    stmt -> FAILWITH
Rule 74    stmt -> FAIL
Rule 75    stmt -> PRINTER

Terminals, with rules where they appear

ABS                  : 31
ADD                  : 32
ADDRESS              : 69
AND                  : 27
BOOL                 : 66
BYTES                : 67
CAR                  : 42
CDR                  : 43
COMPARE              : 29
CONCAT               : 39
CONS                 : 56
CONTRACT             : 62
DIP                  : 71
DROP                 : 10
DUP                  : 11
EDIV                 : 35
EMPTY_MAP            : 47
EMPTY_SET            : 44
EQ                   : 20
EXEC                 : 59
FAIL                 : 74
FAILWITH             : 73
FALSE                : 15
GE                   : 25
GET                  : 50
GT                   : 23
IF_CONS              : 51
INT                  : 65
ITER                 : 49
LAMBDA               : 9
LBRACKET             : 6 7 8
LE                   : 24
LEFT                 : 54
LPAIR                : 70
LPARENS              : 19 70
LSL                  : 36
LSR                  : 37
LT                   : 22
MAP                  : 48
MEM                  : 45
MUL                  : 34
MUTEZ                : 
NAT                  : 63
NEG                  : 30
NEQ                  : 21
NIL                  : 57
NONE                 : 53
NOT                  : 58
NOW                  : 61
NUMBER               : 16
OPERATION            : 68
OR                   : 26
PAIR                 : 41
PAIR_CONSTRUCTOR     : 19
PRINTER              : 75
PUSH                 : 72
RBRACKET             : 6 7 8
RIGHT                : 55
RPARENS              : 19 70
SCOLON               : 2 5 6
SIZE                 : 38
SLICE                : 40
SOME                 : 52
STEPS_TO_QUOTA       : 60
STRING               : 64
SUB                  : 33
SWAP                 : 12
TEXT                 : 18
TIMESTAMP            : 
TRUE                 : 14
UNIT                 : 13
UPDATE               : 46
XOR                  : 28
error                : 

Nonterminals, with rules where they appear

body                 : 3 9 48 49 51 51 71
bool                 : 17
compound_statement   : 1 2 5 6 7
execution            : 0
stmt                 : 4 5
type                 : 9 9 44 47 47 53 54 55 57 62 70 70 72
value                : 19 19 72

Parsing method: LALR

state 0

    (0) S' -> . execution
    (1) execution -> . compound_statement
    (2) execution -> . compound_statement SCOLON
    (3) execution -> . body
    (4) compound_statement -> . stmt
    (5) compound_statement -> . compound_statement SCOLON stmt
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET
    (9) stmt -> . LAMBDA type type body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . SIZE
    (39) stmt -> . CONCAT
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET type
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . EMPTY_MAP type type
    (48) stmt -> . MAP body
    (49) stmt -> . ITER body
    (50) stmt -> . GET
    (51) stmt -> . IF_CONS body body
    (52) stmt -> . SOME
    (53) stmt -> . NONE type
    (54) stmt -> . LEFT type
    (55) stmt -> . RIGHT type
    (56) stmt -> . CONS
    (57) stmt -> . NIL type
    (58) stmt -> . NOT
    (59) stmt -> . EXEC
    (60) stmt -> . STEPS_TO_QUOTA
    (61) stmt -> . NOW
    (62) stmt -> . CONTRACT type
    (71) stmt -> . DIP body
    (72) stmt -> . PUSH type value
    (73) stmt -> . FAILWITH
    (74) stmt -> . FAIL
    (75) stmt -> . PRINTER

    LBRACKET        shift and go to state 5
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    SIZE            shift and go to state 29
    CONCAT          shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    EMPTY_MAP       shift and go to state 38
    MAP             shift and go to state 39
    ITER            shift and go to state 40
    GET             shift and go to state 41
    IF_CONS         shift and go to state 42
    SOME            shift and go to state 43
    NONE            shift and go to state 44
    LEFT            shift and go to state 45
    RIGHT           shift and go to state 46
    CONS            shift and go to state 47
    NIL             shift and go to state 48
    NOT             shift and go to state 49
    EXEC            shift and go to state 50
    STEPS_TO_QUOTA  shift and go to state 51
    NOW             shift and go to state 52
    CONTRACT        shift and go to state 53
    DIP             shift and go to state 54
    PUSH            shift and go to state 55
    FAILWITH        shift and go to state 56
    FAIL            shift and go to state 57
    PRINTER         shift and go to state 58

    execution                      shift and go to state 1
    compound_statement             shift and go to state 2
    body                           shift and go to state 3
    stmt                           shift and go to state 4

state 1

    (0) S' -> execution .



state 2

    (1) execution -> compound_statement .
    (2) execution -> compound_statement . SCOLON
    (5) compound_statement -> compound_statement . SCOLON stmt

    $end            reduce using rule 1 (execution -> compound_statement .)
    SCOLON          shift and go to state 59


state 3

    (3) execution -> body .

    $end            reduce using rule 3 (execution -> body .)


state 4

    (4) compound_statement -> stmt .

    SCOLON          reduce using rule 4 (compound_statement -> stmt .)
    $end            reduce using rule 4 (compound_statement -> stmt .)
    RBRACKET        reduce using rule 4 (compound_statement -> stmt .)


state 5

    (6) body -> LBRACKET . compound_statement SCOLON RBRACKET
    (7) body -> LBRACKET . compound_statement RBRACKET
    (8) body -> LBRACKET . RBRACKET
    (4) compound_statement -> . stmt
    (5) compound_statement -> . compound_statement SCOLON stmt
    (9) stmt -> . LAMBDA type type body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . SIZE
    (39) stmt -> . CONCAT
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET type
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . EMPTY_MAP type type
    (48) stmt -> . MAP body
    (49) stmt -> . ITER body
    (50) stmt -> . GET
    (51) stmt -> . IF_CONS body body
    (52) stmt -> . SOME
    (53) stmt -> . NONE type
    (54) stmt -> . LEFT type
    (55) stmt -> . RIGHT type
    (56) stmt -> . CONS
    (57) stmt -> . NIL type
    (58) stmt -> . NOT
    (59) stmt -> . EXEC
    (60) stmt -> . STEPS_TO_QUOTA
    (61) stmt -> . NOW
    (62) stmt -> . CONTRACT type
    (71) stmt -> . DIP body
    (72) stmt -> . PUSH type value
    (73) stmt -> . FAILWITH
    (74) stmt -> . FAIL
    (75) stmt -> . PRINTER

    RBRACKET        shift and go to state 61
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    SIZE            shift and go to state 29
    CONCAT          shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    EMPTY_MAP       shift and go to state 38
    MAP             shift and go to state 39
    ITER            shift and go to state 40
    GET             shift and go to state 41
    IF_CONS         shift and go to state 42
    SOME            shift and go to state 43
    NONE            shift and go to state 44
    LEFT            shift and go to state 45
    RIGHT           shift and go to state 46
    CONS            shift and go to state 47
    NIL             shift and go to state 48
    NOT             shift and go to state 49
    EXEC            shift and go to state 50
    STEPS_TO_QUOTA  shift and go to state 51
    NOW             shift and go to state 52
    CONTRACT        shift and go to state 53
    DIP             shift and go to state 54
    PUSH            shift and go to state 55
    FAILWITH        shift and go to state 56
    FAIL            shift and go to state 57
    PRINTER         shift and go to state 58

    compound_statement             shift and go to state 60
    stmt                           shift and go to state 4

state 6

    (9) stmt -> LAMBDA . type type body
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 62

state 7

    (10) stmt -> DROP .

    SCOLON          reduce using rule 10 (stmt -> DROP .)
    $end            reduce using rule 10 (stmt -> DROP .)
    RBRACKET        reduce using rule 10 (stmt -> DROP .)


state 8

    (11) stmt -> DUP .

    SCOLON          reduce using rule 11 (stmt -> DUP .)
    $end            reduce using rule 11 (stmt -> DUP .)
    RBRACKET        reduce using rule 11 (stmt -> DUP .)


state 9

    (12) stmt -> SWAP .

    SCOLON          reduce using rule 12 (stmt -> SWAP .)
    $end            reduce using rule 12 (stmt -> SWAP .)
    RBRACKET        reduce using rule 12 (stmt -> SWAP .)


state 10

    (13) stmt -> UNIT .

    SCOLON          reduce using rule 13 (stmt -> UNIT .)
    $end            reduce using rule 13 (stmt -> UNIT .)
    RBRACKET        reduce using rule 13 (stmt -> UNIT .)


state 11

    (20) stmt -> EQ .

    SCOLON          reduce using rule 20 (stmt -> EQ .)
    $end            reduce using rule 20 (stmt -> EQ .)
    RBRACKET        reduce using rule 20 (stmt -> EQ .)


state 12

    (21) stmt -> NEQ .

    SCOLON          reduce using rule 21 (stmt -> NEQ .)
    $end            reduce using rule 21 (stmt -> NEQ .)
    RBRACKET        reduce using rule 21 (stmt -> NEQ .)


state 13

    (22) stmt -> LT .

    SCOLON          reduce using rule 22 (stmt -> LT .)
    $end            reduce using rule 22 (stmt -> LT .)
    RBRACKET        reduce using rule 22 (stmt -> LT .)


state 14

    (23) stmt -> GT .

    SCOLON          reduce using rule 23 (stmt -> GT .)
    $end            reduce using rule 23 (stmt -> GT .)
    RBRACKET        reduce using rule 23 (stmt -> GT .)


state 15

    (24) stmt -> LE .

    SCOLON          reduce using rule 24 (stmt -> LE .)
    $end            reduce using rule 24 (stmt -> LE .)
    RBRACKET        reduce using rule 24 (stmt -> LE .)


state 16

    (25) stmt -> GE .

    SCOLON          reduce using rule 25 (stmt -> GE .)
    $end            reduce using rule 25 (stmt -> GE .)
    RBRACKET        reduce using rule 25 (stmt -> GE .)


state 17

    (26) stmt -> OR .

    SCOLON          reduce using rule 26 (stmt -> OR .)
    $end            reduce using rule 26 (stmt -> OR .)
    RBRACKET        reduce using rule 26 (stmt -> OR .)


state 18

    (27) stmt -> AND .

    SCOLON          reduce using rule 27 (stmt -> AND .)
    $end            reduce using rule 27 (stmt -> AND .)
    RBRACKET        reduce using rule 27 (stmt -> AND .)


state 19

    (28) stmt -> XOR .

    SCOLON          reduce using rule 28 (stmt -> XOR .)
    $end            reduce using rule 28 (stmt -> XOR .)
    RBRACKET        reduce using rule 28 (stmt -> XOR .)


state 20

    (29) stmt -> COMPARE .

    SCOLON          reduce using rule 29 (stmt -> COMPARE .)
    $end            reduce using rule 29 (stmt -> COMPARE .)
    RBRACKET        reduce using rule 29 (stmt -> COMPARE .)


state 21

    (30) stmt -> NEG .

    SCOLON          reduce using rule 30 (stmt -> NEG .)
    $end            reduce using rule 30 (stmt -> NEG .)
    RBRACKET        reduce using rule 30 (stmt -> NEG .)


state 22

    (31) stmt -> ABS .

    SCOLON          reduce using rule 31 (stmt -> ABS .)
    $end            reduce using rule 31 (stmt -> ABS .)
    RBRACKET        reduce using rule 31 (stmt -> ABS .)


state 23

    (32) stmt -> ADD .

    SCOLON          reduce using rule 32 (stmt -> ADD .)
    $end            reduce using rule 32 (stmt -> ADD .)
    RBRACKET        reduce using rule 32 (stmt -> ADD .)


state 24

    (33) stmt -> SUB .

    SCOLON          reduce using rule 33 (stmt -> SUB .)
    $end            reduce using rule 33 (stmt -> SUB .)
    RBRACKET        reduce using rule 33 (stmt -> SUB .)


state 25

    (34) stmt -> MUL .

    SCOLON          reduce using rule 34 (stmt -> MUL .)
    $end            reduce using rule 34 (stmt -> MUL .)
    RBRACKET        reduce using rule 34 (stmt -> MUL .)


state 26

    (35) stmt -> EDIV .

    SCOLON          reduce using rule 35 (stmt -> EDIV .)
    $end            reduce using rule 35 (stmt -> EDIV .)
    RBRACKET        reduce using rule 35 (stmt -> EDIV .)


state 27

    (36) stmt -> LSL .

    SCOLON          reduce using rule 36 (stmt -> LSL .)
    $end            reduce using rule 36 (stmt -> LSL .)
    RBRACKET        reduce using rule 36 (stmt -> LSL .)


state 28

    (37) stmt -> LSR .

    SCOLON          reduce using rule 37 (stmt -> LSR .)
    $end            reduce using rule 37 (stmt -> LSR .)
    RBRACKET        reduce using rule 37 (stmt -> LSR .)


state 29

    (38) stmt -> SIZE .

    SCOLON          reduce using rule 38 (stmt -> SIZE .)
    $end            reduce using rule 38 (stmt -> SIZE .)
    RBRACKET        reduce using rule 38 (stmt -> SIZE .)


state 30

    (39) stmt -> CONCAT .

    SCOLON          reduce using rule 39 (stmt -> CONCAT .)
    $end            reduce using rule 39 (stmt -> CONCAT .)
    RBRACKET        reduce using rule 39 (stmt -> CONCAT .)


state 31

    (40) stmt -> SLICE .

    SCOLON          reduce using rule 40 (stmt -> SLICE .)
    $end            reduce using rule 40 (stmt -> SLICE .)
    RBRACKET        reduce using rule 40 (stmt -> SLICE .)


state 32

    (41) stmt -> PAIR .

    SCOLON          reduce using rule 41 (stmt -> PAIR .)
    $end            reduce using rule 41 (stmt -> PAIR .)
    RBRACKET        reduce using rule 41 (stmt -> PAIR .)


state 33

    (42) stmt -> CAR .

    SCOLON          reduce using rule 42 (stmt -> CAR .)
    $end            reduce using rule 42 (stmt -> CAR .)
    RBRACKET        reduce using rule 42 (stmt -> CAR .)


state 34

    (43) stmt -> CDR .

    SCOLON          reduce using rule 43 (stmt -> CDR .)
    $end            reduce using rule 43 (stmt -> CDR .)
    RBRACKET        reduce using rule 43 (stmt -> CDR .)


state 35

    (44) stmt -> EMPTY_SET . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 71

state 36

    (45) stmt -> MEM .

    SCOLON          reduce using rule 45 (stmt -> MEM .)
    $end            reduce using rule 45 (stmt -> MEM .)
    RBRACKET        reduce using rule 45 (stmt -> MEM .)


state 37

    (46) stmt -> UPDATE .

    SCOLON          reduce using rule 46 (stmt -> UPDATE .)
    $end            reduce using rule 46 (stmt -> UPDATE .)
    RBRACKET        reduce using rule 46 (stmt -> UPDATE .)


state 38

    (47) stmt -> EMPTY_MAP . type type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 72

state 39

    (48) stmt -> MAP . body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 73

state 40

    (49) stmt -> ITER . body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 74

state 41

    (50) stmt -> GET .

    SCOLON          reduce using rule 50 (stmt -> GET .)
    $end            reduce using rule 50 (stmt -> GET .)
    RBRACKET        reduce using rule 50 (stmt -> GET .)


state 42

    (51) stmt -> IF_CONS . body body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 75

state 43

    (52) stmt -> SOME .

    SCOLON          reduce using rule 52 (stmt -> SOME .)
    $end            reduce using rule 52 (stmt -> SOME .)
    RBRACKET        reduce using rule 52 (stmt -> SOME .)


state 44

    (53) stmt -> NONE . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 76

state 45

    (54) stmt -> LEFT . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 77

state 46

    (55) stmt -> RIGHT . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 78

state 47

    (56) stmt -> CONS .

    SCOLON          reduce using rule 56 (stmt -> CONS .)
    $end            reduce using rule 56 (stmt -> CONS .)
    RBRACKET        reduce using rule 56 (stmt -> CONS .)


state 48

    (57) stmt -> NIL . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 79

state 49

    (58) stmt -> NOT .

    SCOLON          reduce using rule 58 (stmt -> NOT .)
    $end            reduce using rule 58 (stmt -> NOT .)
    RBRACKET        reduce using rule 58 (stmt -> NOT .)


state 50

    (59) stmt -> EXEC .

    SCOLON          reduce using rule 59 (stmt -> EXEC .)
    $end            reduce using rule 59 (stmt -> EXEC .)
    RBRACKET        reduce using rule 59 (stmt -> EXEC .)


state 51

    (60) stmt -> STEPS_TO_QUOTA .

    SCOLON          reduce using rule 60 (stmt -> STEPS_TO_QUOTA .)
    $end            reduce using rule 60 (stmt -> STEPS_TO_QUOTA .)
    RBRACKET        reduce using rule 60 (stmt -> STEPS_TO_QUOTA .)


state 52

    (61) stmt -> NOW .

    SCOLON          reduce using rule 61 (stmt -> NOW .)
    $end            reduce using rule 61 (stmt -> NOW .)
    RBRACKET        reduce using rule 61 (stmt -> NOW .)


state 53

    (62) stmt -> CONTRACT . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 80

state 54

    (71) stmt -> DIP . body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 81

state 55

    (72) stmt -> PUSH . type value
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 82

state 56

    (73) stmt -> FAILWITH .

    SCOLON          reduce using rule 73 (stmt -> FAILWITH .)
    $end            reduce using rule 73 (stmt -> FAILWITH .)
    RBRACKET        reduce using rule 73 (stmt -> FAILWITH .)


state 57

    (74) stmt -> FAIL .

    SCOLON          reduce using rule 74 (stmt -> FAIL .)
    $end            reduce using rule 74 (stmt -> FAIL .)
    RBRACKET        reduce using rule 74 (stmt -> FAIL .)


state 58

    (75) stmt -> PRINTER .

    SCOLON          reduce using rule 75 (stmt -> PRINTER .)
    $end            reduce using rule 75 (stmt -> PRINTER .)
    RBRACKET        reduce using rule 75 (stmt -> PRINTER .)


state 59

    (2) execution -> compound_statement SCOLON .
    (5) compound_statement -> compound_statement SCOLON . stmt
    (9) stmt -> . LAMBDA type type body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . SIZE
    (39) stmt -> . CONCAT
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET type
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . EMPTY_MAP type type
    (48) stmt -> . MAP body
    (49) stmt -> . ITER body
    (50) stmt -> . GET
    (51) stmt -> . IF_CONS body body
    (52) stmt -> . SOME
    (53) stmt -> . NONE type
    (54) stmt -> . LEFT type
    (55) stmt -> . RIGHT type
    (56) stmt -> . CONS
    (57) stmt -> . NIL type
    (58) stmt -> . NOT
    (59) stmt -> . EXEC
    (60) stmt -> . STEPS_TO_QUOTA
    (61) stmt -> . NOW
    (62) stmt -> . CONTRACT type
    (71) stmt -> . DIP body
    (72) stmt -> . PUSH type value
    (73) stmt -> . FAILWITH
    (74) stmt -> . FAIL
    (75) stmt -> . PRINTER

    $end            reduce using rule 2 (execution -> compound_statement SCOLON .)
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    SIZE            shift and go to state 29
    CONCAT          shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    EMPTY_MAP       shift and go to state 38
    MAP             shift and go to state 39
    ITER            shift and go to state 40
    GET             shift and go to state 41
    IF_CONS         shift and go to state 42
    SOME            shift and go to state 43
    NONE            shift and go to state 44
    LEFT            shift and go to state 45
    RIGHT           shift and go to state 46
    CONS            shift and go to state 47
    NIL             shift and go to state 48
    NOT             shift and go to state 49
    EXEC            shift and go to state 50
    STEPS_TO_QUOTA  shift and go to state 51
    NOW             shift and go to state 52
    CONTRACT        shift and go to state 53
    DIP             shift and go to state 54
    PUSH            shift and go to state 55
    FAILWITH        shift and go to state 56
    FAIL            shift and go to state 57
    PRINTER         shift and go to state 58

    stmt                           shift and go to state 83

state 60

    (6) body -> LBRACKET compound_statement . SCOLON RBRACKET
    (7) body -> LBRACKET compound_statement . RBRACKET
    (5) compound_statement -> compound_statement . SCOLON stmt

    SCOLON          shift and go to state 84
    RBRACKET        shift and go to state 85


state 61

    (8) body -> LBRACKET RBRACKET .

    $end            reduce using rule 8 (body -> LBRACKET RBRACKET .)
    SCOLON          reduce using rule 8 (body -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 8 (body -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 8 (body -> LBRACKET RBRACKET .)


state 62

    (9) stmt -> LAMBDA type . type body
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 86

state 63

    (63) type -> NAT .

    NAT             reduce using rule 63 (type -> NAT .)
    STRING          reduce using rule 63 (type -> NAT .)
    INT             reduce using rule 63 (type -> NAT .)
    BOOL            reduce using rule 63 (type -> NAT .)
    BYTES           reduce using rule 63 (type -> NAT .)
    OPERATION       reduce using rule 63 (type -> NAT .)
    ADDRESS         reduce using rule 63 (type -> NAT .)
    LPARENS         reduce using rule 63 (type -> NAT .)
    SCOLON          reduce using rule 63 (type -> NAT .)
    $end            reduce using rule 63 (type -> NAT .)
    RBRACKET        reduce using rule 63 (type -> NAT .)
    NUMBER          reduce using rule 63 (type -> NAT .)
    TEXT            reduce using rule 63 (type -> NAT .)
    TRUE            reduce using rule 63 (type -> NAT .)
    FALSE           reduce using rule 63 (type -> NAT .)
    LBRACKET        reduce using rule 63 (type -> NAT .)
    RPARENS         reduce using rule 63 (type -> NAT .)


state 64

    (64) type -> STRING .

    NAT             reduce using rule 64 (type -> STRING .)
    STRING          reduce using rule 64 (type -> STRING .)
    INT             reduce using rule 64 (type -> STRING .)
    BOOL            reduce using rule 64 (type -> STRING .)
    BYTES           reduce using rule 64 (type -> STRING .)
    OPERATION       reduce using rule 64 (type -> STRING .)
    ADDRESS         reduce using rule 64 (type -> STRING .)
    LPARENS         reduce using rule 64 (type -> STRING .)
    SCOLON          reduce using rule 64 (type -> STRING .)
    $end            reduce using rule 64 (type -> STRING .)
    RBRACKET        reduce using rule 64 (type -> STRING .)
    NUMBER          reduce using rule 64 (type -> STRING .)
    TEXT            reduce using rule 64 (type -> STRING .)
    TRUE            reduce using rule 64 (type -> STRING .)
    FALSE           reduce using rule 64 (type -> STRING .)
    LBRACKET        reduce using rule 64 (type -> STRING .)
    RPARENS         reduce using rule 64 (type -> STRING .)


state 65

    (65) type -> INT .

    NAT             reduce using rule 65 (type -> INT .)
    STRING          reduce using rule 65 (type -> INT .)
    INT             reduce using rule 65 (type -> INT .)
    BOOL            reduce using rule 65 (type -> INT .)
    BYTES           reduce using rule 65 (type -> INT .)
    OPERATION       reduce using rule 65 (type -> INT .)
    ADDRESS         reduce using rule 65 (type -> INT .)
    LPARENS         reduce using rule 65 (type -> INT .)
    SCOLON          reduce using rule 65 (type -> INT .)
    $end            reduce using rule 65 (type -> INT .)
    RBRACKET        reduce using rule 65 (type -> INT .)
    NUMBER          reduce using rule 65 (type -> INT .)
    TEXT            reduce using rule 65 (type -> INT .)
    TRUE            reduce using rule 65 (type -> INT .)
    FALSE           reduce using rule 65 (type -> INT .)
    LBRACKET        reduce using rule 65 (type -> INT .)
    RPARENS         reduce using rule 65 (type -> INT .)


state 66

    (66) type -> BOOL .

    NAT             reduce using rule 66 (type -> BOOL .)
    STRING          reduce using rule 66 (type -> BOOL .)
    INT             reduce using rule 66 (type -> BOOL .)
    BOOL            reduce using rule 66 (type -> BOOL .)
    BYTES           reduce using rule 66 (type -> BOOL .)
    OPERATION       reduce using rule 66 (type -> BOOL .)
    ADDRESS         reduce using rule 66 (type -> BOOL .)
    LPARENS         reduce using rule 66 (type -> BOOL .)
    SCOLON          reduce using rule 66 (type -> BOOL .)
    $end            reduce using rule 66 (type -> BOOL .)
    RBRACKET        reduce using rule 66 (type -> BOOL .)
    NUMBER          reduce using rule 66 (type -> BOOL .)
    TEXT            reduce using rule 66 (type -> BOOL .)
    TRUE            reduce using rule 66 (type -> BOOL .)
    FALSE           reduce using rule 66 (type -> BOOL .)
    LBRACKET        reduce using rule 66 (type -> BOOL .)
    RPARENS         reduce using rule 66 (type -> BOOL .)


state 67

    (67) type -> BYTES .

    NAT             reduce using rule 67 (type -> BYTES .)
    STRING          reduce using rule 67 (type -> BYTES .)
    INT             reduce using rule 67 (type -> BYTES .)
    BOOL            reduce using rule 67 (type -> BYTES .)
    BYTES           reduce using rule 67 (type -> BYTES .)
    OPERATION       reduce using rule 67 (type -> BYTES .)
    ADDRESS         reduce using rule 67 (type -> BYTES .)
    LPARENS         reduce using rule 67 (type -> BYTES .)
    SCOLON          reduce using rule 67 (type -> BYTES .)
    $end            reduce using rule 67 (type -> BYTES .)
    RBRACKET        reduce using rule 67 (type -> BYTES .)
    NUMBER          reduce using rule 67 (type -> BYTES .)
    TEXT            reduce using rule 67 (type -> BYTES .)
    TRUE            reduce using rule 67 (type -> BYTES .)
    FALSE           reduce using rule 67 (type -> BYTES .)
    LBRACKET        reduce using rule 67 (type -> BYTES .)
    RPARENS         reduce using rule 67 (type -> BYTES .)


state 68

    (68) type -> OPERATION .

    NAT             reduce using rule 68 (type -> OPERATION .)
    STRING          reduce using rule 68 (type -> OPERATION .)
    INT             reduce using rule 68 (type -> OPERATION .)
    BOOL            reduce using rule 68 (type -> OPERATION .)
    BYTES           reduce using rule 68 (type -> OPERATION .)
    OPERATION       reduce using rule 68 (type -> OPERATION .)
    ADDRESS         reduce using rule 68 (type -> OPERATION .)
    LPARENS         reduce using rule 68 (type -> OPERATION .)
    SCOLON          reduce using rule 68 (type -> OPERATION .)
    $end            reduce using rule 68 (type -> OPERATION .)
    RBRACKET        reduce using rule 68 (type -> OPERATION .)
    NUMBER          reduce using rule 68 (type -> OPERATION .)
    TEXT            reduce using rule 68 (type -> OPERATION .)
    TRUE            reduce using rule 68 (type -> OPERATION .)
    FALSE           reduce using rule 68 (type -> OPERATION .)
    LBRACKET        reduce using rule 68 (type -> OPERATION .)
    RPARENS         reduce using rule 68 (type -> OPERATION .)


state 69

    (69) type -> ADDRESS .

    NAT             reduce using rule 69 (type -> ADDRESS .)
    STRING          reduce using rule 69 (type -> ADDRESS .)
    INT             reduce using rule 69 (type -> ADDRESS .)
    BOOL            reduce using rule 69 (type -> ADDRESS .)
    BYTES           reduce using rule 69 (type -> ADDRESS .)
    OPERATION       reduce using rule 69 (type -> ADDRESS .)
    ADDRESS         reduce using rule 69 (type -> ADDRESS .)
    LPARENS         reduce using rule 69 (type -> ADDRESS .)
    SCOLON          reduce using rule 69 (type -> ADDRESS .)
    $end            reduce using rule 69 (type -> ADDRESS .)
    RBRACKET        reduce using rule 69 (type -> ADDRESS .)
    NUMBER          reduce using rule 69 (type -> ADDRESS .)
    TEXT            reduce using rule 69 (type -> ADDRESS .)
    TRUE            reduce using rule 69 (type -> ADDRESS .)
    FALSE           reduce using rule 69 (type -> ADDRESS .)
    LBRACKET        reduce using rule 69 (type -> ADDRESS .)
    RPARENS         reduce using rule 69 (type -> ADDRESS .)


state 70

    (70) type -> LPARENS . LPAIR type type RPARENS

    LPAIR           shift and go to state 87


state 71

    (44) stmt -> EMPTY_SET type .

    SCOLON          reduce using rule 44 (stmt -> EMPTY_SET type .)
    $end            reduce using rule 44 (stmt -> EMPTY_SET type .)
    RBRACKET        reduce using rule 44 (stmt -> EMPTY_SET type .)


state 72

    (47) stmt -> EMPTY_MAP type . type
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 88

state 73

    (48) stmt -> MAP body .

    SCOLON          reduce using rule 48 (stmt -> MAP body .)
    $end            reduce using rule 48 (stmt -> MAP body .)
    RBRACKET        reduce using rule 48 (stmt -> MAP body .)


state 74

    (49) stmt -> ITER body .

    SCOLON          reduce using rule 49 (stmt -> ITER body .)
    $end            reduce using rule 49 (stmt -> ITER body .)
    RBRACKET        reduce using rule 49 (stmt -> ITER body .)


state 75

    (51) stmt -> IF_CONS body . body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 89

state 76

    (53) stmt -> NONE type .

    SCOLON          reduce using rule 53 (stmt -> NONE type .)
    $end            reduce using rule 53 (stmt -> NONE type .)
    RBRACKET        reduce using rule 53 (stmt -> NONE type .)


state 77

    (54) stmt -> LEFT type .

    SCOLON          reduce using rule 54 (stmt -> LEFT type .)
    $end            reduce using rule 54 (stmt -> LEFT type .)
    RBRACKET        reduce using rule 54 (stmt -> LEFT type .)


state 78

    (55) stmt -> RIGHT type .

    SCOLON          reduce using rule 55 (stmt -> RIGHT type .)
    $end            reduce using rule 55 (stmt -> RIGHT type .)
    RBRACKET        reduce using rule 55 (stmt -> RIGHT type .)


state 79

    (57) stmt -> NIL type .

    SCOLON          reduce using rule 57 (stmt -> NIL type .)
    $end            reduce using rule 57 (stmt -> NIL type .)
    RBRACKET        reduce using rule 57 (stmt -> NIL type .)


state 80

    (62) stmt -> CONTRACT type .

    SCOLON          reduce using rule 62 (stmt -> CONTRACT type .)
    $end            reduce using rule 62 (stmt -> CONTRACT type .)
    RBRACKET        reduce using rule 62 (stmt -> CONTRACT type .)


state 81

    (71) stmt -> DIP body .

    SCOLON          reduce using rule 71 (stmt -> DIP body .)
    $end            reduce using rule 71 (stmt -> DIP body .)
    RBRACKET        reduce using rule 71 (stmt -> DIP body .)


state 82

    (72) stmt -> PUSH type . value
    (16) value -> . NUMBER
    (17) value -> . bool
    (18) value -> . TEXT
    (19) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (14) bool -> . TRUE
    (15) bool -> . FALSE

    NUMBER          shift and go to state 91
    TEXT            shift and go to state 93
    LPARENS         shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96

    value                          shift and go to state 90
    bool                           shift and go to state 92

state 83

    (5) compound_statement -> compound_statement SCOLON stmt .

    SCOLON          reduce using rule 5 (compound_statement -> compound_statement SCOLON stmt .)
    $end            reduce using rule 5 (compound_statement -> compound_statement SCOLON stmt .)
    RBRACKET        reduce using rule 5 (compound_statement -> compound_statement SCOLON stmt .)


state 84

    (6) body -> LBRACKET compound_statement SCOLON . RBRACKET
    (5) compound_statement -> compound_statement SCOLON . stmt
    (9) stmt -> . LAMBDA type type body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . SIZE
    (39) stmt -> . CONCAT
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET type
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . EMPTY_MAP type type
    (48) stmt -> . MAP body
    (49) stmt -> . ITER body
    (50) stmt -> . GET
    (51) stmt -> . IF_CONS body body
    (52) stmt -> . SOME
    (53) stmt -> . NONE type
    (54) stmt -> . LEFT type
    (55) stmt -> . RIGHT type
    (56) stmt -> . CONS
    (57) stmt -> . NIL type
    (58) stmt -> . NOT
    (59) stmt -> . EXEC
    (60) stmt -> . STEPS_TO_QUOTA
    (61) stmt -> . NOW
    (62) stmt -> . CONTRACT type
    (71) stmt -> . DIP body
    (72) stmt -> . PUSH type value
    (73) stmt -> . FAILWITH
    (74) stmt -> . FAIL
    (75) stmt -> . PRINTER

    RBRACKET        shift and go to state 97
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    SIZE            shift and go to state 29
    CONCAT          shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    EMPTY_MAP       shift and go to state 38
    MAP             shift and go to state 39
    ITER            shift and go to state 40
    GET             shift and go to state 41
    IF_CONS         shift and go to state 42
    SOME            shift and go to state 43
    NONE            shift and go to state 44
    LEFT            shift and go to state 45
    RIGHT           shift and go to state 46
    CONS            shift and go to state 47
    NIL             shift and go to state 48
    NOT             shift and go to state 49
    EXEC            shift and go to state 50
    STEPS_TO_QUOTA  shift and go to state 51
    NOW             shift and go to state 52
    CONTRACT        shift and go to state 53
    DIP             shift and go to state 54
    PUSH            shift and go to state 55
    FAILWITH        shift and go to state 56
    FAIL            shift and go to state 57
    PRINTER         shift and go to state 58

    stmt                           shift and go to state 83

state 85

    (7) body -> LBRACKET compound_statement RBRACKET .

    $end            reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)
    SCOLON          reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)
    RBRACKET        reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)
    LBRACKET        reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)


state 86

    (9) stmt -> LAMBDA type type . body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 98

state 87

    (70) type -> LPARENS LPAIR . type type RPARENS
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 99

state 88

    (47) stmt -> EMPTY_MAP type type .

    SCOLON          reduce using rule 47 (stmt -> EMPTY_MAP type type .)
    $end            reduce using rule 47 (stmt -> EMPTY_MAP type type .)
    RBRACKET        reduce using rule 47 (stmt -> EMPTY_MAP type type .)


state 89

    (51) stmt -> IF_CONS body body .

    SCOLON          reduce using rule 51 (stmt -> IF_CONS body body .)
    $end            reduce using rule 51 (stmt -> IF_CONS body body .)
    RBRACKET        reduce using rule 51 (stmt -> IF_CONS body body .)


state 90

    (72) stmt -> PUSH type value .

    SCOLON          reduce using rule 72 (stmt -> PUSH type value .)
    $end            reduce using rule 72 (stmt -> PUSH type value .)
    RBRACKET        reduce using rule 72 (stmt -> PUSH type value .)


state 91

    (16) value -> NUMBER .

    SCOLON          reduce using rule 16 (value -> NUMBER .)
    $end            reduce using rule 16 (value -> NUMBER .)
    RBRACKET        reduce using rule 16 (value -> NUMBER .)
    NUMBER          reduce using rule 16 (value -> NUMBER .)
    TEXT            reduce using rule 16 (value -> NUMBER .)
    LPARENS         reduce using rule 16 (value -> NUMBER .)
    TRUE            reduce using rule 16 (value -> NUMBER .)
    FALSE           reduce using rule 16 (value -> NUMBER .)
    RPARENS         reduce using rule 16 (value -> NUMBER .)


state 92

    (17) value -> bool .

    SCOLON          reduce using rule 17 (value -> bool .)
    $end            reduce using rule 17 (value -> bool .)
    RBRACKET        reduce using rule 17 (value -> bool .)
    NUMBER          reduce using rule 17 (value -> bool .)
    TEXT            reduce using rule 17 (value -> bool .)
    LPARENS         reduce using rule 17 (value -> bool .)
    TRUE            reduce using rule 17 (value -> bool .)
    FALSE           reduce using rule 17 (value -> bool .)
    RPARENS         reduce using rule 17 (value -> bool .)


state 93

    (18) value -> TEXT .

    SCOLON          reduce using rule 18 (value -> TEXT .)
    $end            reduce using rule 18 (value -> TEXT .)
    RBRACKET        reduce using rule 18 (value -> TEXT .)
    NUMBER          reduce using rule 18 (value -> TEXT .)
    TEXT            reduce using rule 18 (value -> TEXT .)
    LPARENS         reduce using rule 18 (value -> TEXT .)
    TRUE            reduce using rule 18 (value -> TEXT .)
    FALSE           reduce using rule 18 (value -> TEXT .)
    RPARENS         reduce using rule 18 (value -> TEXT .)


state 94

    (19) value -> LPARENS . PAIR_CONSTRUCTOR value value RPARENS

    PAIR_CONSTRUCTOR shift and go to state 100


state 95

    (14) bool -> TRUE .

    SCOLON          reduce using rule 14 (bool -> TRUE .)
    $end            reduce using rule 14 (bool -> TRUE .)
    RBRACKET        reduce using rule 14 (bool -> TRUE .)
    NUMBER          reduce using rule 14 (bool -> TRUE .)
    TEXT            reduce using rule 14 (bool -> TRUE .)
    LPARENS         reduce using rule 14 (bool -> TRUE .)
    TRUE            reduce using rule 14 (bool -> TRUE .)
    FALSE           reduce using rule 14 (bool -> TRUE .)
    RPARENS         reduce using rule 14 (bool -> TRUE .)


state 96

    (15) bool -> FALSE .

    SCOLON          reduce using rule 15 (bool -> FALSE .)
    $end            reduce using rule 15 (bool -> FALSE .)
    RBRACKET        reduce using rule 15 (bool -> FALSE .)
    NUMBER          reduce using rule 15 (bool -> FALSE .)
    TEXT            reduce using rule 15 (bool -> FALSE .)
    LPARENS         reduce using rule 15 (bool -> FALSE .)
    TRUE            reduce using rule 15 (bool -> FALSE .)
    FALSE           reduce using rule 15 (bool -> FALSE .)
    RPARENS         reduce using rule 15 (bool -> FALSE .)


state 97

    (6) body -> LBRACKET compound_statement SCOLON RBRACKET .

    $end            reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    SCOLON          reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    RBRACKET        reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    LBRACKET        reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)


state 98

    (9) stmt -> LAMBDA type type body .

    SCOLON          reduce using rule 9 (stmt -> LAMBDA type type body .)
    $end            reduce using rule 9 (stmt -> LAMBDA type type body .)
    RBRACKET        reduce using rule 9 (stmt -> LAMBDA type type body .)


state 99

    (70) type -> LPARENS LPAIR type . type RPARENS
    (63) type -> . NAT
    (64) type -> . STRING
    (65) type -> . INT
    (66) type -> . BOOL
    (67) type -> . BYTES
    (68) type -> . OPERATION
    (69) type -> . ADDRESS
    (70) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 63
    STRING          shift and go to state 64
    INT             shift and go to state 65
    BOOL            shift and go to state 66
    BYTES           shift and go to state 67
    OPERATION       shift and go to state 68
    ADDRESS         shift and go to state 69
    LPARENS         shift and go to state 70

    type                           shift and go to state 101

state 100

    (19) value -> LPARENS PAIR_CONSTRUCTOR . value value RPARENS
    (16) value -> . NUMBER
    (17) value -> . bool
    (18) value -> . TEXT
    (19) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (14) bool -> . TRUE
    (15) bool -> . FALSE

    NUMBER          shift and go to state 91
    TEXT            shift and go to state 93
    LPARENS         shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96

    value                          shift and go to state 102
    bool                           shift and go to state 92

state 101

    (70) type -> LPARENS LPAIR type type . RPARENS

    RPARENS         shift and go to state 103


state 102

    (19) value -> LPARENS PAIR_CONSTRUCTOR value . value RPARENS
    (16) value -> . NUMBER
    (17) value -> . bool
    (18) value -> . TEXT
    (19) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (14) bool -> . TRUE
    (15) bool -> . FALSE

    NUMBER          shift and go to state 91
    TEXT            shift and go to state 93
    LPARENS         shift and go to state 94
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96

    value                          shift and go to state 104
    bool                           shift and go to state 92

state 103

    (70) type -> LPARENS LPAIR type type RPARENS .

    NAT             reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    STRING          reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    INT             reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    BOOL            reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    BYTES           reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    OPERATION       reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    ADDRESS         reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    LPARENS         reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    SCOLON          reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    $end            reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    RBRACKET        reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    NUMBER          reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    TEXT            reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    TRUE            reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    FALSE           reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    LBRACKET        reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)
    RPARENS         reduce using rule 70 (type -> LPARENS LPAIR type type RPARENS .)


state 104

    (19) value -> LPARENS PAIR_CONSTRUCTOR value value . RPARENS

    RPARENS         shift and go to state 105


state 105

    (19) value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .

    SCOLON          reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    $end            reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RBRACKET        reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    NUMBER          reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TEXT            reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    LPARENS         reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TRUE            reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    FALSE           reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RPARENS         reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)

