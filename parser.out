Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MUTEZ

Grammar

Rule 0     S' -> contract_run
Rule 1     contract_run -> contract_decl code_decl
Rule 2     contract_run -> execution
Rule 3     contract_decl -> PARAMETER type SCOLON STORAGE type SCOLON
Rule 4     code_decl -> CODE body
Rule 5     execution -> compound_statement
Rule 6     execution -> compound_statement SCOLON
Rule 7     execution -> body
Rule 8     compound_statement -> stmt
Rule 9     compound_statement -> compound_statement SCOLON stmt
Rule 10    body -> LBRACKET compound_statement SCOLON RBRACKET
Rule 11    body -> LBRACKET compound_statement RBRACKET
Rule 12    body -> LBRACKET RBRACKET
Rule 13    stmt -> LAMBDA type type body
Rule 14    stmt -> DROP
Rule 15    stmt -> DUP
Rule 16    stmt -> SWAP
Rule 17    stmt -> UNIT
Rule 18    bool -> TRUE
Rule 19    bool -> FALSE
Rule 20    value -> NUMBER
Rule 21    value -> bool
Rule 22    value -> TEXT
Rule 23    value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS
Rule 24    stmt -> EQ
Rule 25    stmt -> NEQ
Rule 26    stmt -> LT
Rule 27    stmt -> GT
Rule 28    stmt -> LE
Rule 29    stmt -> GE
Rule 30    stmt -> OR
Rule 31    stmt -> AND
Rule 32    stmt -> XOR
Rule 33    stmt -> COMPARE
Rule 34    stmt -> NEG
Rule 35    stmt -> ABS
Rule 36    stmt -> ADD
Rule 37    stmt -> SUB
Rule 38    stmt -> MUL
Rule 39    stmt -> EDIV
Rule 40    stmt -> LSL
Rule 41    stmt -> LSR
Rule 42    stmt -> SIZE
Rule 43    stmt -> CONCAT
Rule 44    stmt -> SLICE
Rule 45    stmt -> PAIR
Rule 46    stmt -> CAR
Rule 47    stmt -> CDR
Rule 48    stmt -> EMPTY_SET type
Rule 49    stmt -> MEM
Rule 50    stmt -> UPDATE
Rule 51    stmt -> EMPTY_MAP type type
Rule 52    stmt -> MAP body
Rule 53    stmt -> ITER body
Rule 54    stmt -> GET
Rule 55    stmt -> IF_CONS body body
Rule 56    stmt -> SOME
Rule 57    stmt -> NONE type
Rule 58    stmt -> LEFT type
Rule 59    stmt -> RIGHT type
Rule 60    stmt -> CONS
Rule 61    stmt -> NIL type
Rule 62    stmt -> NOT
Rule 63    stmt -> EXEC
Rule 64    stmt -> STEPS_TO_QUOTA
Rule 65    stmt -> NOW
Rule 66    stmt -> CONTRACT type
Rule 67    stmt -> HASH_KEY
Rule 68    stmt -> BLAKE2B
Rule 69    stmt -> SHA256
Rule 70    stmt -> SHA512
Rule 71    stmt -> CHECK_SIGNATURE
Rule 72    type -> NAT
Rule 73    type -> STRING
Rule 74    type -> INT
Rule 75    type -> BOOL
Rule 76    type -> BYTES
Rule 77    type -> OPERATION
Rule 78    type -> ADDRESS
Rule 79    type -> TIMESTAMP
Rule 80    type -> LPARENS LPAIR type type RPARENS
Rule 81    stmt -> DIP body
Rule 82    stmt -> PUSH type value
Rule 83    stmt -> FAILWITH
Rule 84    stmt -> FAIL
Rule 85    stmt -> PRINTER

Terminals, with rules where they appear

ABS                  : 35
ADD                  : 36
ADDRESS              : 78
AND                  : 31
BLAKE2B              : 68
BOOL                 : 75
BYTES                : 76
CAR                  : 46
CDR                  : 47
CHECK_SIGNATURE      : 71
CODE                 : 4
COMPARE              : 33
CONCAT               : 43
CONS                 : 60
CONTRACT             : 66
DIP                  : 81
DROP                 : 14
DUP                  : 15
EDIV                 : 39
EMPTY_MAP            : 51
EMPTY_SET            : 48
EQ                   : 24
EXEC                 : 63
FAIL                 : 84
FAILWITH             : 83
FALSE                : 19
GE                   : 29
GET                  : 54
GT                   : 27
HASH_KEY             : 67
IF_CONS              : 55
INT                  : 74
ITER                 : 53
LAMBDA               : 13
LBRACKET             : 10 11 12
LE                   : 28
LEFT                 : 58
LPAIR                : 80
LPARENS              : 23 80
LSL                  : 40
LSR                  : 41
LT                   : 26
MAP                  : 52
MEM                  : 49
MUL                  : 38
MUTEZ                : 
NAT                  : 72
NEG                  : 34
NEQ                  : 25
NIL                  : 61
NONE                 : 57
NOT                  : 62
NOW                  : 65
NUMBER               : 20
OPERATION            : 77
OR                   : 30
PAIR                 : 45
PAIR_CONSTRUCTOR     : 23
PARAMETER            : 3
PRINTER              : 85
PUSH                 : 82
RBRACKET             : 10 11 12
RIGHT                : 59
RPARENS              : 23 80
SCOLON               : 3 3 6 9 10
SHA256               : 69
SHA512               : 70
SIZE                 : 42
SLICE                : 44
SOME                 : 56
STEPS_TO_QUOTA       : 64
STORAGE              : 3
STRING               : 73
SUB                  : 37
SWAP                 : 16
TEXT                 : 22
TIMESTAMP            : 79
TRUE                 : 18
UNIT                 : 17
UPDATE               : 50
XOR                  : 32
error                : 

Nonterminals, with rules where they appear

body                 : 4 7 13 52 53 55 55 81
bool                 : 21
code_decl            : 1
compound_statement   : 5 6 9 10 11
contract_decl        : 1
contract_run         : 0
execution            : 2
stmt                 : 8 9
type                 : 3 3 13 13 48 51 51 57 58 59 61 66 80 80 82
value                : 23 23 82

Parsing method: LALR

state 0

    (0) S' -> . contract_run
    (1) contract_run -> . contract_decl code_decl
    (2) contract_run -> . execution
    (3) contract_decl -> . PARAMETER type SCOLON STORAGE type SCOLON
    (5) execution -> . compound_statement
    (6) execution -> . compound_statement SCOLON
    (7) execution -> . body
    (8) compound_statement -> . stmt
    (9) compound_statement -> . compound_statement SCOLON stmt
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_CONS body body
    (56) stmt -> . SOME
    (57) stmt -> . NONE type
    (58) stmt -> . LEFT type
    (59) stmt -> . RIGHT type
    (60) stmt -> . CONS
    (61) stmt -> . NIL type
    (62) stmt -> . NOT
    (63) stmt -> . EXEC
    (64) stmt -> . STEPS_TO_QUOTA
    (65) stmt -> . NOW
    (66) stmt -> . CONTRACT type
    (67) stmt -> . HASH_KEY
    (68) stmt -> . BLAKE2B
    (69) stmt -> . SHA256
    (70) stmt -> . SHA512
    (71) stmt -> . CHECK_SIGNATURE
    (81) stmt -> . DIP body
    (82) stmt -> . PUSH type value
    (83) stmt -> . FAILWITH
    (84) stmt -> . FAIL
    (85) stmt -> . PRINTER

    PARAMETER       shift and go to state 4
    LBRACKET        shift and go to state 8
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_CONS         shift and go to state 45
    SOME            shift and go to state 46
    NONE            shift and go to state 47
    LEFT            shift and go to state 48
    RIGHT           shift and go to state 49
    CONS            shift and go to state 50
    NIL             shift and go to state 51
    NOT             shift and go to state 52
    EXEC            shift and go to state 53
    STEPS_TO_QUOTA  shift and go to state 54
    NOW             shift and go to state 55
    CONTRACT        shift and go to state 56
    HASH_KEY        shift and go to state 57
    BLAKE2B         shift and go to state 58
    SHA256          shift and go to state 59
    SHA512          shift and go to state 60
    CHECK_SIGNATURE shift and go to state 61
    DIP             shift and go to state 62
    PUSH            shift and go to state 63
    FAILWITH        shift and go to state 64
    FAIL            shift and go to state 65
    PRINTER         shift and go to state 66

    contract_run                   shift and go to state 1
    contract_decl                  shift and go to state 2
    execution                      shift and go to state 3
    compound_statement             shift and go to state 5
    body                           shift and go to state 6
    stmt                           shift and go to state 7

state 1

    (0) S' -> contract_run .



state 2

    (1) contract_run -> contract_decl . code_decl
    (4) code_decl -> . CODE body

    CODE            shift and go to state 68

    code_decl                      shift and go to state 67

state 3

    (2) contract_run -> execution .

    $end            reduce using rule 2 (contract_run -> execution .)


state 4

    (3) contract_decl -> PARAMETER . type SCOLON STORAGE type SCOLON
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 69

state 5

    (5) execution -> compound_statement .
    (6) execution -> compound_statement . SCOLON
    (9) compound_statement -> compound_statement . SCOLON stmt

    $end            reduce using rule 5 (execution -> compound_statement .)
    SCOLON          shift and go to state 79


state 6

    (7) execution -> body .

    $end            reduce using rule 7 (execution -> body .)


state 7

    (8) compound_statement -> stmt .

    SCOLON          reduce using rule 8 (compound_statement -> stmt .)
    $end            reduce using rule 8 (compound_statement -> stmt .)
    RBRACKET        reduce using rule 8 (compound_statement -> stmt .)


state 8

    (10) body -> LBRACKET . compound_statement SCOLON RBRACKET
    (11) body -> LBRACKET . compound_statement RBRACKET
    (12) body -> LBRACKET . RBRACKET
    (8) compound_statement -> . stmt
    (9) compound_statement -> . compound_statement SCOLON stmt
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_CONS body body
    (56) stmt -> . SOME
    (57) stmt -> . NONE type
    (58) stmt -> . LEFT type
    (59) stmt -> . RIGHT type
    (60) stmt -> . CONS
    (61) stmt -> . NIL type
    (62) stmt -> . NOT
    (63) stmt -> . EXEC
    (64) stmt -> . STEPS_TO_QUOTA
    (65) stmt -> . NOW
    (66) stmt -> . CONTRACT type
    (67) stmt -> . HASH_KEY
    (68) stmt -> . BLAKE2B
    (69) stmt -> . SHA256
    (70) stmt -> . SHA512
    (71) stmt -> . CHECK_SIGNATURE
    (81) stmt -> . DIP body
    (82) stmt -> . PUSH type value
    (83) stmt -> . FAILWITH
    (84) stmt -> . FAIL
    (85) stmt -> . PRINTER

    RBRACKET        shift and go to state 81
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_CONS         shift and go to state 45
    SOME            shift and go to state 46
    NONE            shift and go to state 47
    LEFT            shift and go to state 48
    RIGHT           shift and go to state 49
    CONS            shift and go to state 50
    NIL             shift and go to state 51
    NOT             shift and go to state 52
    EXEC            shift and go to state 53
    STEPS_TO_QUOTA  shift and go to state 54
    NOW             shift and go to state 55
    CONTRACT        shift and go to state 56
    HASH_KEY        shift and go to state 57
    BLAKE2B         shift and go to state 58
    SHA256          shift and go to state 59
    SHA512          shift and go to state 60
    CHECK_SIGNATURE shift and go to state 61
    DIP             shift and go to state 62
    PUSH            shift and go to state 63
    FAILWITH        shift and go to state 64
    FAIL            shift and go to state 65
    PRINTER         shift and go to state 66

    compound_statement             shift and go to state 80
    stmt                           shift and go to state 7

state 9

    (13) stmt -> LAMBDA . type type body
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 82

state 10

    (14) stmt -> DROP .

    SCOLON          reduce using rule 14 (stmt -> DROP .)
    $end            reduce using rule 14 (stmt -> DROP .)
    RBRACKET        reduce using rule 14 (stmt -> DROP .)


state 11

    (15) stmt -> DUP .

    SCOLON          reduce using rule 15 (stmt -> DUP .)
    $end            reduce using rule 15 (stmt -> DUP .)
    RBRACKET        reduce using rule 15 (stmt -> DUP .)


state 12

    (16) stmt -> SWAP .

    SCOLON          reduce using rule 16 (stmt -> SWAP .)
    $end            reduce using rule 16 (stmt -> SWAP .)
    RBRACKET        reduce using rule 16 (stmt -> SWAP .)


state 13

    (17) stmt -> UNIT .

    SCOLON          reduce using rule 17 (stmt -> UNIT .)
    $end            reduce using rule 17 (stmt -> UNIT .)
    RBRACKET        reduce using rule 17 (stmt -> UNIT .)


state 14

    (24) stmt -> EQ .

    SCOLON          reduce using rule 24 (stmt -> EQ .)
    $end            reduce using rule 24 (stmt -> EQ .)
    RBRACKET        reduce using rule 24 (stmt -> EQ .)


state 15

    (25) stmt -> NEQ .

    SCOLON          reduce using rule 25 (stmt -> NEQ .)
    $end            reduce using rule 25 (stmt -> NEQ .)
    RBRACKET        reduce using rule 25 (stmt -> NEQ .)


state 16

    (26) stmt -> LT .

    SCOLON          reduce using rule 26 (stmt -> LT .)
    $end            reduce using rule 26 (stmt -> LT .)
    RBRACKET        reduce using rule 26 (stmt -> LT .)


state 17

    (27) stmt -> GT .

    SCOLON          reduce using rule 27 (stmt -> GT .)
    $end            reduce using rule 27 (stmt -> GT .)
    RBRACKET        reduce using rule 27 (stmt -> GT .)


state 18

    (28) stmt -> LE .

    SCOLON          reduce using rule 28 (stmt -> LE .)
    $end            reduce using rule 28 (stmt -> LE .)
    RBRACKET        reduce using rule 28 (stmt -> LE .)


state 19

    (29) stmt -> GE .

    SCOLON          reduce using rule 29 (stmt -> GE .)
    $end            reduce using rule 29 (stmt -> GE .)
    RBRACKET        reduce using rule 29 (stmt -> GE .)


state 20

    (30) stmt -> OR .

    SCOLON          reduce using rule 30 (stmt -> OR .)
    $end            reduce using rule 30 (stmt -> OR .)
    RBRACKET        reduce using rule 30 (stmt -> OR .)


state 21

    (31) stmt -> AND .

    SCOLON          reduce using rule 31 (stmt -> AND .)
    $end            reduce using rule 31 (stmt -> AND .)
    RBRACKET        reduce using rule 31 (stmt -> AND .)


state 22

    (32) stmt -> XOR .

    SCOLON          reduce using rule 32 (stmt -> XOR .)
    $end            reduce using rule 32 (stmt -> XOR .)
    RBRACKET        reduce using rule 32 (stmt -> XOR .)


state 23

    (33) stmt -> COMPARE .

    SCOLON          reduce using rule 33 (stmt -> COMPARE .)
    $end            reduce using rule 33 (stmt -> COMPARE .)
    RBRACKET        reduce using rule 33 (stmt -> COMPARE .)


state 24

    (34) stmt -> NEG .

    SCOLON          reduce using rule 34 (stmt -> NEG .)
    $end            reduce using rule 34 (stmt -> NEG .)
    RBRACKET        reduce using rule 34 (stmt -> NEG .)


state 25

    (35) stmt -> ABS .

    SCOLON          reduce using rule 35 (stmt -> ABS .)
    $end            reduce using rule 35 (stmt -> ABS .)
    RBRACKET        reduce using rule 35 (stmt -> ABS .)


state 26

    (36) stmt -> ADD .

    SCOLON          reduce using rule 36 (stmt -> ADD .)
    $end            reduce using rule 36 (stmt -> ADD .)
    RBRACKET        reduce using rule 36 (stmt -> ADD .)


state 27

    (37) stmt -> SUB .

    SCOLON          reduce using rule 37 (stmt -> SUB .)
    $end            reduce using rule 37 (stmt -> SUB .)
    RBRACKET        reduce using rule 37 (stmt -> SUB .)


state 28

    (38) stmt -> MUL .

    SCOLON          reduce using rule 38 (stmt -> MUL .)
    $end            reduce using rule 38 (stmt -> MUL .)
    RBRACKET        reduce using rule 38 (stmt -> MUL .)


state 29

    (39) stmt -> EDIV .

    SCOLON          reduce using rule 39 (stmt -> EDIV .)
    $end            reduce using rule 39 (stmt -> EDIV .)
    RBRACKET        reduce using rule 39 (stmt -> EDIV .)


state 30

    (40) stmt -> LSL .

    SCOLON          reduce using rule 40 (stmt -> LSL .)
    $end            reduce using rule 40 (stmt -> LSL .)
    RBRACKET        reduce using rule 40 (stmt -> LSL .)


state 31

    (41) stmt -> LSR .

    SCOLON          reduce using rule 41 (stmt -> LSR .)
    $end            reduce using rule 41 (stmt -> LSR .)
    RBRACKET        reduce using rule 41 (stmt -> LSR .)


state 32

    (42) stmt -> SIZE .

    SCOLON          reduce using rule 42 (stmt -> SIZE .)
    $end            reduce using rule 42 (stmt -> SIZE .)
    RBRACKET        reduce using rule 42 (stmt -> SIZE .)


state 33

    (43) stmt -> CONCAT .

    SCOLON          reduce using rule 43 (stmt -> CONCAT .)
    $end            reduce using rule 43 (stmt -> CONCAT .)
    RBRACKET        reduce using rule 43 (stmt -> CONCAT .)


state 34

    (44) stmt -> SLICE .

    SCOLON          reduce using rule 44 (stmt -> SLICE .)
    $end            reduce using rule 44 (stmt -> SLICE .)
    RBRACKET        reduce using rule 44 (stmt -> SLICE .)


state 35

    (45) stmt -> PAIR .

    SCOLON          reduce using rule 45 (stmt -> PAIR .)
    $end            reduce using rule 45 (stmt -> PAIR .)
    RBRACKET        reduce using rule 45 (stmt -> PAIR .)


state 36

    (46) stmt -> CAR .

    SCOLON          reduce using rule 46 (stmt -> CAR .)
    $end            reduce using rule 46 (stmt -> CAR .)
    RBRACKET        reduce using rule 46 (stmt -> CAR .)


state 37

    (47) stmt -> CDR .

    SCOLON          reduce using rule 47 (stmt -> CDR .)
    $end            reduce using rule 47 (stmt -> CDR .)
    RBRACKET        reduce using rule 47 (stmt -> CDR .)


state 38

    (48) stmt -> EMPTY_SET . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 83

state 39

    (49) stmt -> MEM .

    SCOLON          reduce using rule 49 (stmt -> MEM .)
    $end            reduce using rule 49 (stmt -> MEM .)
    RBRACKET        reduce using rule 49 (stmt -> MEM .)


state 40

    (50) stmt -> UPDATE .

    SCOLON          reduce using rule 50 (stmt -> UPDATE .)
    $end            reduce using rule 50 (stmt -> UPDATE .)
    RBRACKET        reduce using rule 50 (stmt -> UPDATE .)


state 41

    (51) stmt -> EMPTY_MAP . type type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 84

state 42

    (52) stmt -> MAP . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 85

state 43

    (53) stmt -> ITER . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 86

state 44

    (54) stmt -> GET .

    SCOLON          reduce using rule 54 (stmt -> GET .)
    $end            reduce using rule 54 (stmt -> GET .)
    RBRACKET        reduce using rule 54 (stmt -> GET .)


state 45

    (55) stmt -> IF_CONS . body body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 87

state 46

    (56) stmt -> SOME .

    SCOLON          reduce using rule 56 (stmt -> SOME .)
    $end            reduce using rule 56 (stmt -> SOME .)
    RBRACKET        reduce using rule 56 (stmt -> SOME .)


state 47

    (57) stmt -> NONE . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 88

state 48

    (58) stmt -> LEFT . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 89

state 49

    (59) stmt -> RIGHT . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 90

state 50

    (60) stmt -> CONS .

    SCOLON          reduce using rule 60 (stmt -> CONS .)
    $end            reduce using rule 60 (stmt -> CONS .)
    RBRACKET        reduce using rule 60 (stmt -> CONS .)


state 51

    (61) stmt -> NIL . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 91

state 52

    (62) stmt -> NOT .

    SCOLON          reduce using rule 62 (stmt -> NOT .)
    $end            reduce using rule 62 (stmt -> NOT .)
    RBRACKET        reduce using rule 62 (stmt -> NOT .)


state 53

    (63) stmt -> EXEC .

    SCOLON          reduce using rule 63 (stmt -> EXEC .)
    $end            reduce using rule 63 (stmt -> EXEC .)
    RBRACKET        reduce using rule 63 (stmt -> EXEC .)


state 54

    (64) stmt -> STEPS_TO_QUOTA .

    SCOLON          reduce using rule 64 (stmt -> STEPS_TO_QUOTA .)
    $end            reduce using rule 64 (stmt -> STEPS_TO_QUOTA .)
    RBRACKET        reduce using rule 64 (stmt -> STEPS_TO_QUOTA .)


state 55

    (65) stmt -> NOW .

    SCOLON          reduce using rule 65 (stmt -> NOW .)
    $end            reduce using rule 65 (stmt -> NOW .)
    RBRACKET        reduce using rule 65 (stmt -> NOW .)


state 56

    (66) stmt -> CONTRACT . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 92

state 57

    (67) stmt -> HASH_KEY .

    SCOLON          reduce using rule 67 (stmt -> HASH_KEY .)
    $end            reduce using rule 67 (stmt -> HASH_KEY .)
    RBRACKET        reduce using rule 67 (stmt -> HASH_KEY .)


state 58

    (68) stmt -> BLAKE2B .

    SCOLON          reduce using rule 68 (stmt -> BLAKE2B .)
    $end            reduce using rule 68 (stmt -> BLAKE2B .)
    RBRACKET        reduce using rule 68 (stmt -> BLAKE2B .)


state 59

    (69) stmt -> SHA256 .

    SCOLON          reduce using rule 69 (stmt -> SHA256 .)
    $end            reduce using rule 69 (stmt -> SHA256 .)
    RBRACKET        reduce using rule 69 (stmt -> SHA256 .)


state 60

    (70) stmt -> SHA512 .

    SCOLON          reduce using rule 70 (stmt -> SHA512 .)
    $end            reduce using rule 70 (stmt -> SHA512 .)
    RBRACKET        reduce using rule 70 (stmt -> SHA512 .)


state 61

    (71) stmt -> CHECK_SIGNATURE .

    SCOLON          reduce using rule 71 (stmt -> CHECK_SIGNATURE .)
    $end            reduce using rule 71 (stmt -> CHECK_SIGNATURE .)
    RBRACKET        reduce using rule 71 (stmt -> CHECK_SIGNATURE .)


state 62

    (81) stmt -> DIP . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 93

state 63

    (82) stmt -> PUSH . type value
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 94

state 64

    (83) stmt -> FAILWITH .

    SCOLON          reduce using rule 83 (stmt -> FAILWITH .)
    $end            reduce using rule 83 (stmt -> FAILWITH .)
    RBRACKET        reduce using rule 83 (stmt -> FAILWITH .)


state 65

    (84) stmt -> FAIL .

    SCOLON          reduce using rule 84 (stmt -> FAIL .)
    $end            reduce using rule 84 (stmt -> FAIL .)
    RBRACKET        reduce using rule 84 (stmt -> FAIL .)


state 66

    (85) stmt -> PRINTER .

    SCOLON          reduce using rule 85 (stmt -> PRINTER .)
    $end            reduce using rule 85 (stmt -> PRINTER .)
    RBRACKET        reduce using rule 85 (stmt -> PRINTER .)


state 67

    (1) contract_run -> contract_decl code_decl .

    $end            reduce using rule 1 (contract_run -> contract_decl code_decl .)


state 68

    (4) code_decl -> CODE . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 95

state 69

    (3) contract_decl -> PARAMETER type . SCOLON STORAGE type SCOLON

    SCOLON          shift and go to state 96


state 70

    (72) type -> NAT .

    SCOLON          reduce using rule 72 (type -> NAT .)
    NAT             reduce using rule 72 (type -> NAT .)
    STRING          reduce using rule 72 (type -> NAT .)
    INT             reduce using rule 72 (type -> NAT .)
    BOOL            reduce using rule 72 (type -> NAT .)
    BYTES           reduce using rule 72 (type -> NAT .)
    OPERATION       reduce using rule 72 (type -> NAT .)
    ADDRESS         reduce using rule 72 (type -> NAT .)
    TIMESTAMP       reduce using rule 72 (type -> NAT .)
    LPARENS         reduce using rule 72 (type -> NAT .)
    $end            reduce using rule 72 (type -> NAT .)
    RBRACKET        reduce using rule 72 (type -> NAT .)
    NUMBER          reduce using rule 72 (type -> NAT .)
    TEXT            reduce using rule 72 (type -> NAT .)
    TRUE            reduce using rule 72 (type -> NAT .)
    FALSE           reduce using rule 72 (type -> NAT .)
    LBRACKET        reduce using rule 72 (type -> NAT .)
    RPARENS         reduce using rule 72 (type -> NAT .)


state 71

    (73) type -> STRING .

    SCOLON          reduce using rule 73 (type -> STRING .)
    NAT             reduce using rule 73 (type -> STRING .)
    STRING          reduce using rule 73 (type -> STRING .)
    INT             reduce using rule 73 (type -> STRING .)
    BOOL            reduce using rule 73 (type -> STRING .)
    BYTES           reduce using rule 73 (type -> STRING .)
    OPERATION       reduce using rule 73 (type -> STRING .)
    ADDRESS         reduce using rule 73 (type -> STRING .)
    TIMESTAMP       reduce using rule 73 (type -> STRING .)
    LPARENS         reduce using rule 73 (type -> STRING .)
    $end            reduce using rule 73 (type -> STRING .)
    RBRACKET        reduce using rule 73 (type -> STRING .)
    NUMBER          reduce using rule 73 (type -> STRING .)
    TEXT            reduce using rule 73 (type -> STRING .)
    TRUE            reduce using rule 73 (type -> STRING .)
    FALSE           reduce using rule 73 (type -> STRING .)
    LBRACKET        reduce using rule 73 (type -> STRING .)
    RPARENS         reduce using rule 73 (type -> STRING .)


state 72

    (74) type -> INT .

    SCOLON          reduce using rule 74 (type -> INT .)
    NAT             reduce using rule 74 (type -> INT .)
    STRING          reduce using rule 74 (type -> INT .)
    INT             reduce using rule 74 (type -> INT .)
    BOOL            reduce using rule 74 (type -> INT .)
    BYTES           reduce using rule 74 (type -> INT .)
    OPERATION       reduce using rule 74 (type -> INT .)
    ADDRESS         reduce using rule 74 (type -> INT .)
    TIMESTAMP       reduce using rule 74 (type -> INT .)
    LPARENS         reduce using rule 74 (type -> INT .)
    $end            reduce using rule 74 (type -> INT .)
    RBRACKET        reduce using rule 74 (type -> INT .)
    NUMBER          reduce using rule 74 (type -> INT .)
    TEXT            reduce using rule 74 (type -> INT .)
    TRUE            reduce using rule 74 (type -> INT .)
    FALSE           reduce using rule 74 (type -> INT .)
    LBRACKET        reduce using rule 74 (type -> INT .)
    RPARENS         reduce using rule 74 (type -> INT .)


state 73

    (75) type -> BOOL .

    SCOLON          reduce using rule 75 (type -> BOOL .)
    NAT             reduce using rule 75 (type -> BOOL .)
    STRING          reduce using rule 75 (type -> BOOL .)
    INT             reduce using rule 75 (type -> BOOL .)
    BOOL            reduce using rule 75 (type -> BOOL .)
    BYTES           reduce using rule 75 (type -> BOOL .)
    OPERATION       reduce using rule 75 (type -> BOOL .)
    ADDRESS         reduce using rule 75 (type -> BOOL .)
    TIMESTAMP       reduce using rule 75 (type -> BOOL .)
    LPARENS         reduce using rule 75 (type -> BOOL .)
    $end            reduce using rule 75 (type -> BOOL .)
    RBRACKET        reduce using rule 75 (type -> BOOL .)
    NUMBER          reduce using rule 75 (type -> BOOL .)
    TEXT            reduce using rule 75 (type -> BOOL .)
    TRUE            reduce using rule 75 (type -> BOOL .)
    FALSE           reduce using rule 75 (type -> BOOL .)
    LBRACKET        reduce using rule 75 (type -> BOOL .)
    RPARENS         reduce using rule 75 (type -> BOOL .)


state 74

    (76) type -> BYTES .

    SCOLON          reduce using rule 76 (type -> BYTES .)
    NAT             reduce using rule 76 (type -> BYTES .)
    STRING          reduce using rule 76 (type -> BYTES .)
    INT             reduce using rule 76 (type -> BYTES .)
    BOOL            reduce using rule 76 (type -> BYTES .)
    BYTES           reduce using rule 76 (type -> BYTES .)
    OPERATION       reduce using rule 76 (type -> BYTES .)
    ADDRESS         reduce using rule 76 (type -> BYTES .)
    TIMESTAMP       reduce using rule 76 (type -> BYTES .)
    LPARENS         reduce using rule 76 (type -> BYTES .)
    $end            reduce using rule 76 (type -> BYTES .)
    RBRACKET        reduce using rule 76 (type -> BYTES .)
    NUMBER          reduce using rule 76 (type -> BYTES .)
    TEXT            reduce using rule 76 (type -> BYTES .)
    TRUE            reduce using rule 76 (type -> BYTES .)
    FALSE           reduce using rule 76 (type -> BYTES .)
    LBRACKET        reduce using rule 76 (type -> BYTES .)
    RPARENS         reduce using rule 76 (type -> BYTES .)


state 75

    (77) type -> OPERATION .

    SCOLON          reduce using rule 77 (type -> OPERATION .)
    NAT             reduce using rule 77 (type -> OPERATION .)
    STRING          reduce using rule 77 (type -> OPERATION .)
    INT             reduce using rule 77 (type -> OPERATION .)
    BOOL            reduce using rule 77 (type -> OPERATION .)
    BYTES           reduce using rule 77 (type -> OPERATION .)
    OPERATION       reduce using rule 77 (type -> OPERATION .)
    ADDRESS         reduce using rule 77 (type -> OPERATION .)
    TIMESTAMP       reduce using rule 77 (type -> OPERATION .)
    LPARENS         reduce using rule 77 (type -> OPERATION .)
    $end            reduce using rule 77 (type -> OPERATION .)
    RBRACKET        reduce using rule 77 (type -> OPERATION .)
    NUMBER          reduce using rule 77 (type -> OPERATION .)
    TEXT            reduce using rule 77 (type -> OPERATION .)
    TRUE            reduce using rule 77 (type -> OPERATION .)
    FALSE           reduce using rule 77 (type -> OPERATION .)
    LBRACKET        reduce using rule 77 (type -> OPERATION .)
    RPARENS         reduce using rule 77 (type -> OPERATION .)


state 76

    (78) type -> ADDRESS .

    SCOLON          reduce using rule 78 (type -> ADDRESS .)
    NAT             reduce using rule 78 (type -> ADDRESS .)
    STRING          reduce using rule 78 (type -> ADDRESS .)
    INT             reduce using rule 78 (type -> ADDRESS .)
    BOOL            reduce using rule 78 (type -> ADDRESS .)
    BYTES           reduce using rule 78 (type -> ADDRESS .)
    OPERATION       reduce using rule 78 (type -> ADDRESS .)
    ADDRESS         reduce using rule 78 (type -> ADDRESS .)
    TIMESTAMP       reduce using rule 78 (type -> ADDRESS .)
    LPARENS         reduce using rule 78 (type -> ADDRESS .)
    $end            reduce using rule 78 (type -> ADDRESS .)
    RBRACKET        reduce using rule 78 (type -> ADDRESS .)
    NUMBER          reduce using rule 78 (type -> ADDRESS .)
    TEXT            reduce using rule 78 (type -> ADDRESS .)
    TRUE            reduce using rule 78 (type -> ADDRESS .)
    FALSE           reduce using rule 78 (type -> ADDRESS .)
    LBRACKET        reduce using rule 78 (type -> ADDRESS .)
    RPARENS         reduce using rule 78 (type -> ADDRESS .)


state 77

    (79) type -> TIMESTAMP .

    SCOLON          reduce using rule 79 (type -> TIMESTAMP .)
    NAT             reduce using rule 79 (type -> TIMESTAMP .)
    STRING          reduce using rule 79 (type -> TIMESTAMP .)
    INT             reduce using rule 79 (type -> TIMESTAMP .)
    BOOL            reduce using rule 79 (type -> TIMESTAMP .)
    BYTES           reduce using rule 79 (type -> TIMESTAMP .)
    OPERATION       reduce using rule 79 (type -> TIMESTAMP .)
    ADDRESS         reduce using rule 79 (type -> TIMESTAMP .)
    TIMESTAMP       reduce using rule 79 (type -> TIMESTAMP .)
    LPARENS         reduce using rule 79 (type -> TIMESTAMP .)
    $end            reduce using rule 79 (type -> TIMESTAMP .)
    RBRACKET        reduce using rule 79 (type -> TIMESTAMP .)
    NUMBER          reduce using rule 79 (type -> TIMESTAMP .)
    TEXT            reduce using rule 79 (type -> TIMESTAMP .)
    TRUE            reduce using rule 79 (type -> TIMESTAMP .)
    FALSE           reduce using rule 79 (type -> TIMESTAMP .)
    LBRACKET        reduce using rule 79 (type -> TIMESTAMP .)
    RPARENS         reduce using rule 79 (type -> TIMESTAMP .)


state 78

    (80) type -> LPARENS . LPAIR type type RPARENS

    LPAIR           shift and go to state 97


state 79

    (6) execution -> compound_statement SCOLON .
    (9) compound_statement -> compound_statement SCOLON . stmt
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_CONS body body
    (56) stmt -> . SOME
    (57) stmt -> . NONE type
    (58) stmt -> . LEFT type
    (59) stmt -> . RIGHT type
    (60) stmt -> . CONS
    (61) stmt -> . NIL type
    (62) stmt -> . NOT
    (63) stmt -> . EXEC
    (64) stmt -> . STEPS_TO_QUOTA
    (65) stmt -> . NOW
    (66) stmt -> . CONTRACT type
    (67) stmt -> . HASH_KEY
    (68) stmt -> . BLAKE2B
    (69) stmt -> . SHA256
    (70) stmt -> . SHA512
    (71) stmt -> . CHECK_SIGNATURE
    (81) stmt -> . DIP body
    (82) stmt -> . PUSH type value
    (83) stmt -> . FAILWITH
    (84) stmt -> . FAIL
    (85) stmt -> . PRINTER

    $end            reduce using rule 6 (execution -> compound_statement SCOLON .)
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_CONS         shift and go to state 45
    SOME            shift and go to state 46
    NONE            shift and go to state 47
    LEFT            shift and go to state 48
    RIGHT           shift and go to state 49
    CONS            shift and go to state 50
    NIL             shift and go to state 51
    NOT             shift and go to state 52
    EXEC            shift and go to state 53
    STEPS_TO_QUOTA  shift and go to state 54
    NOW             shift and go to state 55
    CONTRACT        shift and go to state 56
    HASH_KEY        shift and go to state 57
    BLAKE2B         shift and go to state 58
    SHA256          shift and go to state 59
    SHA512          shift and go to state 60
    CHECK_SIGNATURE shift and go to state 61
    DIP             shift and go to state 62
    PUSH            shift and go to state 63
    FAILWITH        shift and go to state 64
    FAIL            shift and go to state 65
    PRINTER         shift and go to state 66

    stmt                           shift and go to state 98

state 80

    (10) body -> LBRACKET compound_statement . SCOLON RBRACKET
    (11) body -> LBRACKET compound_statement . RBRACKET
    (9) compound_statement -> compound_statement . SCOLON stmt

    SCOLON          shift and go to state 99
    RBRACKET        shift and go to state 100


state 81

    (12) body -> LBRACKET RBRACKET .

    $end            reduce using rule 12 (body -> LBRACKET RBRACKET .)
    SCOLON          reduce using rule 12 (body -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 12 (body -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 12 (body -> LBRACKET RBRACKET .)


state 82

    (13) stmt -> LAMBDA type . type body
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 101

state 83

    (48) stmt -> EMPTY_SET type .

    SCOLON          reduce using rule 48 (stmt -> EMPTY_SET type .)
    $end            reduce using rule 48 (stmt -> EMPTY_SET type .)
    RBRACKET        reduce using rule 48 (stmt -> EMPTY_SET type .)


state 84

    (51) stmt -> EMPTY_MAP type . type
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 102

state 85

    (52) stmt -> MAP body .

    SCOLON          reduce using rule 52 (stmt -> MAP body .)
    $end            reduce using rule 52 (stmt -> MAP body .)
    RBRACKET        reduce using rule 52 (stmt -> MAP body .)


state 86

    (53) stmt -> ITER body .

    SCOLON          reduce using rule 53 (stmt -> ITER body .)
    $end            reduce using rule 53 (stmt -> ITER body .)
    RBRACKET        reduce using rule 53 (stmt -> ITER body .)


state 87

    (55) stmt -> IF_CONS body . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 103

state 88

    (57) stmt -> NONE type .

    SCOLON          reduce using rule 57 (stmt -> NONE type .)
    $end            reduce using rule 57 (stmt -> NONE type .)
    RBRACKET        reduce using rule 57 (stmt -> NONE type .)


state 89

    (58) stmt -> LEFT type .

    SCOLON          reduce using rule 58 (stmt -> LEFT type .)
    $end            reduce using rule 58 (stmt -> LEFT type .)
    RBRACKET        reduce using rule 58 (stmt -> LEFT type .)


state 90

    (59) stmt -> RIGHT type .

    SCOLON          reduce using rule 59 (stmt -> RIGHT type .)
    $end            reduce using rule 59 (stmt -> RIGHT type .)
    RBRACKET        reduce using rule 59 (stmt -> RIGHT type .)


state 91

    (61) stmt -> NIL type .

    SCOLON          reduce using rule 61 (stmt -> NIL type .)
    $end            reduce using rule 61 (stmt -> NIL type .)
    RBRACKET        reduce using rule 61 (stmt -> NIL type .)


state 92

    (66) stmt -> CONTRACT type .

    SCOLON          reduce using rule 66 (stmt -> CONTRACT type .)
    $end            reduce using rule 66 (stmt -> CONTRACT type .)
    RBRACKET        reduce using rule 66 (stmt -> CONTRACT type .)


state 93

    (81) stmt -> DIP body .

    SCOLON          reduce using rule 81 (stmt -> DIP body .)
    $end            reduce using rule 81 (stmt -> DIP body .)
    RBRACKET        reduce using rule 81 (stmt -> DIP body .)


state 94

    (82) stmt -> PUSH type . value
    (20) value -> . NUMBER
    (21) value -> . bool
    (22) value -> . TEXT
    (23) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (18) bool -> . TRUE
    (19) bool -> . FALSE

    NUMBER          shift and go to state 105
    TEXT            shift and go to state 107
    LPARENS         shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110

    value                          shift and go to state 104
    bool                           shift and go to state 106

state 95

    (4) code_decl -> CODE body .

    $end            reduce using rule 4 (code_decl -> CODE body .)


state 96

    (3) contract_decl -> PARAMETER type SCOLON . STORAGE type SCOLON

    STORAGE         shift and go to state 111


state 97

    (80) type -> LPARENS LPAIR . type type RPARENS
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 112

state 98

    (9) compound_statement -> compound_statement SCOLON stmt .

    SCOLON          reduce using rule 9 (compound_statement -> compound_statement SCOLON stmt .)
    $end            reduce using rule 9 (compound_statement -> compound_statement SCOLON stmt .)
    RBRACKET        reduce using rule 9 (compound_statement -> compound_statement SCOLON stmt .)


state 99

    (10) body -> LBRACKET compound_statement SCOLON . RBRACKET
    (9) compound_statement -> compound_statement SCOLON . stmt
    (13) stmt -> . LAMBDA type type body
    (14) stmt -> . DROP
    (15) stmt -> . DUP
    (16) stmt -> . SWAP
    (17) stmt -> . UNIT
    (24) stmt -> . EQ
    (25) stmt -> . NEQ
    (26) stmt -> . LT
    (27) stmt -> . GT
    (28) stmt -> . LE
    (29) stmt -> . GE
    (30) stmt -> . OR
    (31) stmt -> . AND
    (32) stmt -> . XOR
    (33) stmt -> . COMPARE
    (34) stmt -> . NEG
    (35) stmt -> . ABS
    (36) stmt -> . ADD
    (37) stmt -> . SUB
    (38) stmt -> . MUL
    (39) stmt -> . EDIV
    (40) stmt -> . LSL
    (41) stmt -> . LSR
    (42) stmt -> . SIZE
    (43) stmt -> . CONCAT
    (44) stmt -> . SLICE
    (45) stmt -> . PAIR
    (46) stmt -> . CAR
    (47) stmt -> . CDR
    (48) stmt -> . EMPTY_SET type
    (49) stmt -> . MEM
    (50) stmt -> . UPDATE
    (51) stmt -> . EMPTY_MAP type type
    (52) stmt -> . MAP body
    (53) stmt -> . ITER body
    (54) stmt -> . GET
    (55) stmt -> . IF_CONS body body
    (56) stmt -> . SOME
    (57) stmt -> . NONE type
    (58) stmt -> . LEFT type
    (59) stmt -> . RIGHT type
    (60) stmt -> . CONS
    (61) stmt -> . NIL type
    (62) stmt -> . NOT
    (63) stmt -> . EXEC
    (64) stmt -> . STEPS_TO_QUOTA
    (65) stmt -> . NOW
    (66) stmt -> . CONTRACT type
    (67) stmt -> . HASH_KEY
    (68) stmt -> . BLAKE2B
    (69) stmt -> . SHA256
    (70) stmt -> . SHA512
    (71) stmt -> . CHECK_SIGNATURE
    (81) stmt -> . DIP body
    (82) stmt -> . PUSH type value
    (83) stmt -> . FAILWITH
    (84) stmt -> . FAIL
    (85) stmt -> . PRINTER

    RBRACKET        shift and go to state 113
    LAMBDA          shift and go to state 9
    DROP            shift and go to state 10
    DUP             shift and go to state 11
    SWAP            shift and go to state 12
    UNIT            shift and go to state 13
    EQ              shift and go to state 14
    NEQ             shift and go to state 15
    LT              shift and go to state 16
    GT              shift and go to state 17
    LE              shift and go to state 18
    GE              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    XOR             shift and go to state 22
    COMPARE         shift and go to state 23
    NEG             shift and go to state 24
    ABS             shift and go to state 25
    ADD             shift and go to state 26
    SUB             shift and go to state 27
    MUL             shift and go to state 28
    EDIV            shift and go to state 29
    LSL             shift and go to state 30
    LSR             shift and go to state 31
    SIZE            shift and go to state 32
    CONCAT          shift and go to state 33
    SLICE           shift and go to state 34
    PAIR            shift and go to state 35
    CAR             shift and go to state 36
    CDR             shift and go to state 37
    EMPTY_SET       shift and go to state 38
    MEM             shift and go to state 39
    UPDATE          shift and go to state 40
    EMPTY_MAP       shift and go to state 41
    MAP             shift and go to state 42
    ITER            shift and go to state 43
    GET             shift and go to state 44
    IF_CONS         shift and go to state 45
    SOME            shift and go to state 46
    NONE            shift and go to state 47
    LEFT            shift and go to state 48
    RIGHT           shift and go to state 49
    CONS            shift and go to state 50
    NIL             shift and go to state 51
    NOT             shift and go to state 52
    EXEC            shift and go to state 53
    STEPS_TO_QUOTA  shift and go to state 54
    NOW             shift and go to state 55
    CONTRACT        shift and go to state 56
    HASH_KEY        shift and go to state 57
    BLAKE2B         shift and go to state 58
    SHA256          shift and go to state 59
    SHA512          shift and go to state 60
    CHECK_SIGNATURE shift and go to state 61
    DIP             shift and go to state 62
    PUSH            shift and go to state 63
    FAILWITH        shift and go to state 64
    FAIL            shift and go to state 65
    PRINTER         shift and go to state 66

    stmt                           shift and go to state 98

state 100

    (11) body -> LBRACKET compound_statement RBRACKET .

    $end            reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)
    SCOLON          reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)
    RBRACKET        reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)
    LBRACKET        reduce using rule 11 (body -> LBRACKET compound_statement RBRACKET .)


state 101

    (13) stmt -> LAMBDA type type . body
    (10) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (11) body -> . LBRACKET compound_statement RBRACKET
    (12) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 8

    body                           shift and go to state 114

state 102

    (51) stmt -> EMPTY_MAP type type .

    SCOLON          reduce using rule 51 (stmt -> EMPTY_MAP type type .)
    $end            reduce using rule 51 (stmt -> EMPTY_MAP type type .)
    RBRACKET        reduce using rule 51 (stmt -> EMPTY_MAP type type .)


state 103

    (55) stmt -> IF_CONS body body .

    SCOLON          reduce using rule 55 (stmt -> IF_CONS body body .)
    $end            reduce using rule 55 (stmt -> IF_CONS body body .)
    RBRACKET        reduce using rule 55 (stmt -> IF_CONS body body .)


state 104

    (82) stmt -> PUSH type value .

    SCOLON          reduce using rule 82 (stmt -> PUSH type value .)
    $end            reduce using rule 82 (stmt -> PUSH type value .)
    RBRACKET        reduce using rule 82 (stmt -> PUSH type value .)


state 105

    (20) value -> NUMBER .

    SCOLON          reduce using rule 20 (value -> NUMBER .)
    $end            reduce using rule 20 (value -> NUMBER .)
    RBRACKET        reduce using rule 20 (value -> NUMBER .)
    NUMBER          reduce using rule 20 (value -> NUMBER .)
    TEXT            reduce using rule 20 (value -> NUMBER .)
    LPARENS         reduce using rule 20 (value -> NUMBER .)
    TRUE            reduce using rule 20 (value -> NUMBER .)
    FALSE           reduce using rule 20 (value -> NUMBER .)
    RPARENS         reduce using rule 20 (value -> NUMBER .)


state 106

    (21) value -> bool .

    SCOLON          reduce using rule 21 (value -> bool .)
    $end            reduce using rule 21 (value -> bool .)
    RBRACKET        reduce using rule 21 (value -> bool .)
    NUMBER          reduce using rule 21 (value -> bool .)
    TEXT            reduce using rule 21 (value -> bool .)
    LPARENS         reduce using rule 21 (value -> bool .)
    TRUE            reduce using rule 21 (value -> bool .)
    FALSE           reduce using rule 21 (value -> bool .)
    RPARENS         reduce using rule 21 (value -> bool .)


state 107

    (22) value -> TEXT .

    SCOLON          reduce using rule 22 (value -> TEXT .)
    $end            reduce using rule 22 (value -> TEXT .)
    RBRACKET        reduce using rule 22 (value -> TEXT .)
    NUMBER          reduce using rule 22 (value -> TEXT .)
    TEXT            reduce using rule 22 (value -> TEXT .)
    LPARENS         reduce using rule 22 (value -> TEXT .)
    TRUE            reduce using rule 22 (value -> TEXT .)
    FALSE           reduce using rule 22 (value -> TEXT .)
    RPARENS         reduce using rule 22 (value -> TEXT .)


state 108

    (23) value -> LPARENS . PAIR_CONSTRUCTOR value value RPARENS

    PAIR_CONSTRUCTOR shift and go to state 115


state 109

    (18) bool -> TRUE .

    SCOLON          reduce using rule 18 (bool -> TRUE .)
    $end            reduce using rule 18 (bool -> TRUE .)
    RBRACKET        reduce using rule 18 (bool -> TRUE .)
    NUMBER          reduce using rule 18 (bool -> TRUE .)
    TEXT            reduce using rule 18 (bool -> TRUE .)
    LPARENS         reduce using rule 18 (bool -> TRUE .)
    TRUE            reduce using rule 18 (bool -> TRUE .)
    FALSE           reduce using rule 18 (bool -> TRUE .)
    RPARENS         reduce using rule 18 (bool -> TRUE .)


state 110

    (19) bool -> FALSE .

    SCOLON          reduce using rule 19 (bool -> FALSE .)
    $end            reduce using rule 19 (bool -> FALSE .)
    RBRACKET        reduce using rule 19 (bool -> FALSE .)
    NUMBER          reduce using rule 19 (bool -> FALSE .)
    TEXT            reduce using rule 19 (bool -> FALSE .)
    LPARENS         reduce using rule 19 (bool -> FALSE .)
    TRUE            reduce using rule 19 (bool -> FALSE .)
    FALSE           reduce using rule 19 (bool -> FALSE .)
    RPARENS         reduce using rule 19 (bool -> FALSE .)


state 111

    (3) contract_decl -> PARAMETER type SCOLON STORAGE . type SCOLON
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 116

state 112

    (80) type -> LPARENS LPAIR type . type RPARENS
    (72) type -> . NAT
    (73) type -> . STRING
    (74) type -> . INT
    (75) type -> . BOOL
    (76) type -> . BYTES
    (77) type -> . OPERATION
    (78) type -> . ADDRESS
    (79) type -> . TIMESTAMP
    (80) type -> . LPARENS LPAIR type type RPARENS

    NAT             shift and go to state 70
    STRING          shift and go to state 71
    INT             shift and go to state 72
    BOOL            shift and go to state 73
    BYTES           shift and go to state 74
    OPERATION       shift and go to state 75
    ADDRESS         shift and go to state 76
    TIMESTAMP       shift and go to state 77
    LPARENS         shift and go to state 78

    type                           shift and go to state 117

state 113

    (10) body -> LBRACKET compound_statement SCOLON RBRACKET .

    $end            reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    SCOLON          reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    RBRACKET        reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    LBRACKET        reduce using rule 10 (body -> LBRACKET compound_statement SCOLON RBRACKET .)


state 114

    (13) stmt -> LAMBDA type type body .

    SCOLON          reduce using rule 13 (stmt -> LAMBDA type type body .)
    $end            reduce using rule 13 (stmt -> LAMBDA type type body .)
    RBRACKET        reduce using rule 13 (stmt -> LAMBDA type type body .)


state 115

    (23) value -> LPARENS PAIR_CONSTRUCTOR . value value RPARENS
    (20) value -> . NUMBER
    (21) value -> . bool
    (22) value -> . TEXT
    (23) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (18) bool -> . TRUE
    (19) bool -> . FALSE

    NUMBER          shift and go to state 105
    TEXT            shift and go to state 107
    LPARENS         shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110

    value                          shift and go to state 118
    bool                           shift and go to state 106

state 116

    (3) contract_decl -> PARAMETER type SCOLON STORAGE type . SCOLON

    SCOLON          shift and go to state 119


state 117

    (80) type -> LPARENS LPAIR type type . RPARENS

    RPARENS         shift and go to state 120


state 118

    (23) value -> LPARENS PAIR_CONSTRUCTOR value . value RPARENS
    (20) value -> . NUMBER
    (21) value -> . bool
    (22) value -> . TEXT
    (23) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (18) bool -> . TRUE
    (19) bool -> . FALSE

    NUMBER          shift and go to state 105
    TEXT            shift and go to state 107
    LPARENS         shift and go to state 108
    TRUE            shift and go to state 109
    FALSE           shift and go to state 110

    value                          shift and go to state 121
    bool                           shift and go to state 106

state 119

    (3) contract_decl -> PARAMETER type SCOLON STORAGE type SCOLON .

    CODE            reduce using rule 3 (contract_decl -> PARAMETER type SCOLON STORAGE type SCOLON .)


state 120

    (80) type -> LPARENS LPAIR type type RPARENS .

    SCOLON          reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    NAT             reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    STRING          reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    INT             reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    BOOL            reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    BYTES           reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    OPERATION       reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    ADDRESS         reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    TIMESTAMP       reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    LPARENS         reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    $end            reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    RBRACKET        reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    NUMBER          reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    TEXT            reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    TRUE            reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    FALSE           reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    LBRACKET        reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)
    RPARENS         reduce using rule 80 (type -> LPARENS LPAIR type type RPARENS .)


state 121

    (23) value -> LPARENS PAIR_CONSTRUCTOR value value . RPARENS

    RPARENS         shift and go to state 122


state 122

    (23) value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .

    SCOLON          reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    $end            reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RBRACKET        reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    NUMBER          reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TEXT            reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    LPARENS         reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TRUE            reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    FALSE           reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RPARENS         reduce using rule 23 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)

