Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EMPTY_MAP
    GET

Grammar

Rule 0     S' -> execution
Rule 1     execution -> compound_statement
Rule 2     execution -> compound_statement SCOLON
Rule 3     execution -> body
Rule 4     compound_statement -> stmt
Rule 5     compound_statement -> compound_statement SCOLON stmt
Rule 6     body -> LBRACKET compound_statement SCOLON RBRACKET
Rule 7     body -> LBRACKET compound_statement RBRACKET
Rule 8     body -> LBRACKET RBRACKET
Rule 9     stmt -> LAMBDA TYPE TYPE body
Rule 10    stmt -> DROP
Rule 11    stmt -> DUP
Rule 12    stmt -> SWAP
Rule 13    stmt -> UNIT
Rule 14    bool -> TRUE
Rule 15    bool -> FALSE
Rule 16    value -> NUMBER
Rule 17    value -> bool
Rule 18    value -> TEXT
Rule 19    value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS
Rule 20    stmt -> EQ
Rule 21    stmt -> NEQ
Rule 22    stmt -> LT
Rule 23    stmt -> GT
Rule 24    stmt -> LE
Rule 25    stmt -> GE
Rule 26    stmt -> OR
Rule 27    stmt -> AND
Rule 28    stmt -> XOR
Rule 29    stmt -> COMPARE
Rule 30    stmt -> NEG
Rule 31    stmt -> ABS
Rule 32    stmt -> ADD
Rule 33    stmt -> SUB
Rule 34    stmt -> MUL
Rule 35    stmt -> EDIV
Rule 36    stmt -> LSL
Rule 37    stmt -> LSR
Rule 38    stmt -> CONCAT
Rule 39    stmt -> SIZE
Rule 40    stmt -> SLICE
Rule 41    stmt -> PAIR
Rule 42    stmt -> CAR
Rule 43    stmt -> CDR
Rule 44    stmt -> EMPTY_SET TYPE
Rule 45    stmt -> MEM
Rule 46    stmt -> UPDATE
Rule 47    stmt -> SOME
Rule 48    stmt -> NONE TYPE
Rule 49    stmt -> LEFT TYPE
Rule 50    stmt -> RIGHT TYPE
Rule 51    stmt -> CONS
Rule 52    stmt -> NIL TYPE
Rule 53    stmt -> NOT
Rule 54    stmt -> EXEC
Rule 55    TYPE -> NAT
Rule 56    TYPE -> STRING
Rule 57    TYPE -> INT
Rule 58    TYPE -> BOOL
Rule 59    TYPE -> BYTES
Rule 60    TYPE -> OPERATION
Rule 61    TYPE -> LPARENS LPAIR TYPE TYPE RPARENS
Rule 62    stmt -> PUSH TYPE value
Rule 63    stmt -> FAILWITH

Terminals, with rules where they appear

ABS                  : 31
ADD                  : 32
AND                  : 27
BOOL                 : 58
BYTES                : 59
CAR                  : 42
CDR                  : 43
COMPARE              : 29
CONCAT               : 38
CONS                 : 51
DROP                 : 10
DUP                  : 11
EDIV                 : 35
EMPTY_MAP            : 
EMPTY_SET            : 44
EQ                   : 20
EXEC                 : 54
FAILWITH             : 63
FALSE                : 15
GE                   : 25
GET                  : 
GT                   : 23
INT                  : 57
LAMBDA               : 9
LBRACKET             : 6 7 8
LE                   : 24
LEFT                 : 49
LPAIR                : 61
LPARENS              : 19 61
LSL                  : 36
LSR                  : 37
LT                   : 22
MEM                  : 45
MUL                  : 34
NAT                  : 55
NEG                  : 30
NEQ                  : 21
NIL                  : 52
NONE                 : 48
NOT                  : 53
NUMBER               : 16
OPERATION            : 60
OR                   : 26
PAIR                 : 41
PAIR_CONSTRUCTOR     : 19
PUSH                 : 62
RBRACKET             : 6 7 8
RIGHT                : 50
RPARENS              : 19 61
SCOLON               : 2 5 6
SIZE                 : 39
SLICE                : 40
SOME                 : 47
STRING               : 56
SUB                  : 33
SWAP                 : 12
TEXT                 : 18
TRUE                 : 14
UNIT                 : 13
UPDATE               : 46
XOR                  : 28
error                : 

Nonterminals, with rules where they appear

TYPE                 : 9 9 44 48 49 50 52 61 61 62
body                 : 3 9
bool                 : 17
compound_statement   : 1 2 5 6 7
execution            : 0
stmt                 : 4 5
value                : 19 19 62

Parsing method: LALR

state 0

    (0) S' -> . execution
    (1) execution -> . compound_statement
    (2) execution -> . compound_statement SCOLON
    (3) execution -> . body
    (4) compound_statement -> . stmt
    (5) compound_statement -> . compound_statement SCOLON stmt
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET
    (9) stmt -> . LAMBDA TYPE TYPE body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . CONCAT
    (39) stmt -> . SIZE
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET TYPE
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . SOME
    (48) stmt -> . NONE TYPE
    (49) stmt -> . LEFT TYPE
    (50) stmt -> . RIGHT TYPE
    (51) stmt -> . CONS
    (52) stmt -> . NIL TYPE
    (53) stmt -> . NOT
    (54) stmt -> . EXEC
    (62) stmt -> . PUSH TYPE value
    (63) stmt -> . FAILWITH

    LBRACKET        shift and go to state 5
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    CONCAT          shift and go to state 29
    SIZE            shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    SOME            shift and go to state 38
    NONE            shift and go to state 39
    LEFT            shift and go to state 40
    RIGHT           shift and go to state 41
    CONS            shift and go to state 42
    NIL             shift and go to state 43
    NOT             shift and go to state 44
    EXEC            shift and go to state 45
    PUSH            shift and go to state 46
    FAILWITH        shift and go to state 47

    execution                      shift and go to state 1
    compound_statement             shift and go to state 2
    body                           shift and go to state 3
    stmt                           shift and go to state 4

state 1

    (0) S' -> execution .



state 2

    (1) execution -> compound_statement .
    (2) execution -> compound_statement . SCOLON
    (5) compound_statement -> compound_statement . SCOLON stmt

    $end            reduce using rule 1 (execution -> compound_statement .)
    SCOLON          shift and go to state 48


state 3

    (3) execution -> body .

    $end            reduce using rule 3 (execution -> body .)


state 4

    (4) compound_statement -> stmt .

    SCOLON          reduce using rule 4 (compound_statement -> stmt .)
    $end            reduce using rule 4 (compound_statement -> stmt .)
    RBRACKET        reduce using rule 4 (compound_statement -> stmt .)


state 5

    (6) body -> LBRACKET . compound_statement SCOLON RBRACKET
    (7) body -> LBRACKET . compound_statement RBRACKET
    (8) body -> LBRACKET . RBRACKET
    (4) compound_statement -> . stmt
    (5) compound_statement -> . compound_statement SCOLON stmt
    (9) stmt -> . LAMBDA TYPE TYPE body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . CONCAT
    (39) stmt -> . SIZE
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET TYPE
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . SOME
    (48) stmt -> . NONE TYPE
    (49) stmt -> . LEFT TYPE
    (50) stmt -> . RIGHT TYPE
    (51) stmt -> . CONS
    (52) stmt -> . NIL TYPE
    (53) stmt -> . NOT
    (54) stmt -> . EXEC
    (62) stmt -> . PUSH TYPE value
    (63) stmt -> . FAILWITH

    RBRACKET        shift and go to state 50
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    CONCAT          shift and go to state 29
    SIZE            shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    SOME            shift and go to state 38
    NONE            shift and go to state 39
    LEFT            shift and go to state 40
    RIGHT           shift and go to state 41
    CONS            shift and go to state 42
    NIL             shift and go to state 43
    NOT             shift and go to state 44
    EXEC            shift and go to state 45
    PUSH            shift and go to state 46
    FAILWITH        shift and go to state 47

    compound_statement             shift and go to state 49
    stmt                           shift and go to state 4

state 6

    (9) stmt -> LAMBDA . TYPE TYPE body
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 51

state 7

    (10) stmt -> DROP .

    SCOLON          reduce using rule 10 (stmt -> DROP .)
    $end            reduce using rule 10 (stmt -> DROP .)
    RBRACKET        reduce using rule 10 (stmt -> DROP .)


state 8

    (11) stmt -> DUP .

    SCOLON          reduce using rule 11 (stmt -> DUP .)
    $end            reduce using rule 11 (stmt -> DUP .)
    RBRACKET        reduce using rule 11 (stmt -> DUP .)


state 9

    (12) stmt -> SWAP .

    SCOLON          reduce using rule 12 (stmt -> SWAP .)
    $end            reduce using rule 12 (stmt -> SWAP .)
    RBRACKET        reduce using rule 12 (stmt -> SWAP .)


state 10

    (13) stmt -> UNIT .

    SCOLON          reduce using rule 13 (stmt -> UNIT .)
    $end            reduce using rule 13 (stmt -> UNIT .)
    RBRACKET        reduce using rule 13 (stmt -> UNIT .)


state 11

    (20) stmt -> EQ .

    SCOLON          reduce using rule 20 (stmt -> EQ .)
    $end            reduce using rule 20 (stmt -> EQ .)
    RBRACKET        reduce using rule 20 (stmt -> EQ .)


state 12

    (21) stmt -> NEQ .

    SCOLON          reduce using rule 21 (stmt -> NEQ .)
    $end            reduce using rule 21 (stmt -> NEQ .)
    RBRACKET        reduce using rule 21 (stmt -> NEQ .)


state 13

    (22) stmt -> LT .

    SCOLON          reduce using rule 22 (stmt -> LT .)
    $end            reduce using rule 22 (stmt -> LT .)
    RBRACKET        reduce using rule 22 (stmt -> LT .)


state 14

    (23) stmt -> GT .

    SCOLON          reduce using rule 23 (stmt -> GT .)
    $end            reduce using rule 23 (stmt -> GT .)
    RBRACKET        reduce using rule 23 (stmt -> GT .)


state 15

    (24) stmt -> LE .

    SCOLON          reduce using rule 24 (stmt -> LE .)
    $end            reduce using rule 24 (stmt -> LE .)
    RBRACKET        reduce using rule 24 (stmt -> LE .)


state 16

    (25) stmt -> GE .

    SCOLON          reduce using rule 25 (stmt -> GE .)
    $end            reduce using rule 25 (stmt -> GE .)
    RBRACKET        reduce using rule 25 (stmt -> GE .)


state 17

    (26) stmt -> OR .

    SCOLON          reduce using rule 26 (stmt -> OR .)
    $end            reduce using rule 26 (stmt -> OR .)
    RBRACKET        reduce using rule 26 (stmt -> OR .)


state 18

    (27) stmt -> AND .

    SCOLON          reduce using rule 27 (stmt -> AND .)
    $end            reduce using rule 27 (stmt -> AND .)
    RBRACKET        reduce using rule 27 (stmt -> AND .)


state 19

    (28) stmt -> XOR .

    SCOLON          reduce using rule 28 (stmt -> XOR .)
    $end            reduce using rule 28 (stmt -> XOR .)
    RBRACKET        reduce using rule 28 (stmt -> XOR .)


state 20

    (29) stmt -> COMPARE .

    SCOLON          reduce using rule 29 (stmt -> COMPARE .)
    $end            reduce using rule 29 (stmt -> COMPARE .)
    RBRACKET        reduce using rule 29 (stmt -> COMPARE .)


state 21

    (30) stmt -> NEG .

    SCOLON          reduce using rule 30 (stmt -> NEG .)
    $end            reduce using rule 30 (stmt -> NEG .)
    RBRACKET        reduce using rule 30 (stmt -> NEG .)


state 22

    (31) stmt -> ABS .

    SCOLON          reduce using rule 31 (stmt -> ABS .)
    $end            reduce using rule 31 (stmt -> ABS .)
    RBRACKET        reduce using rule 31 (stmt -> ABS .)


state 23

    (32) stmt -> ADD .

    SCOLON          reduce using rule 32 (stmt -> ADD .)
    $end            reduce using rule 32 (stmt -> ADD .)
    RBRACKET        reduce using rule 32 (stmt -> ADD .)


state 24

    (33) stmt -> SUB .

    SCOLON          reduce using rule 33 (stmt -> SUB .)
    $end            reduce using rule 33 (stmt -> SUB .)
    RBRACKET        reduce using rule 33 (stmt -> SUB .)


state 25

    (34) stmt -> MUL .

    SCOLON          reduce using rule 34 (stmt -> MUL .)
    $end            reduce using rule 34 (stmt -> MUL .)
    RBRACKET        reduce using rule 34 (stmt -> MUL .)


state 26

    (35) stmt -> EDIV .

    SCOLON          reduce using rule 35 (stmt -> EDIV .)
    $end            reduce using rule 35 (stmt -> EDIV .)
    RBRACKET        reduce using rule 35 (stmt -> EDIV .)


state 27

    (36) stmt -> LSL .

    SCOLON          reduce using rule 36 (stmt -> LSL .)
    $end            reduce using rule 36 (stmt -> LSL .)
    RBRACKET        reduce using rule 36 (stmt -> LSL .)


state 28

    (37) stmt -> LSR .

    SCOLON          reduce using rule 37 (stmt -> LSR .)
    $end            reduce using rule 37 (stmt -> LSR .)
    RBRACKET        reduce using rule 37 (stmt -> LSR .)


state 29

    (38) stmt -> CONCAT .

    SCOLON          reduce using rule 38 (stmt -> CONCAT .)
    $end            reduce using rule 38 (stmt -> CONCAT .)
    RBRACKET        reduce using rule 38 (stmt -> CONCAT .)


state 30

    (39) stmt -> SIZE .

    SCOLON          reduce using rule 39 (stmt -> SIZE .)
    $end            reduce using rule 39 (stmt -> SIZE .)
    RBRACKET        reduce using rule 39 (stmt -> SIZE .)


state 31

    (40) stmt -> SLICE .

    SCOLON          reduce using rule 40 (stmt -> SLICE .)
    $end            reduce using rule 40 (stmt -> SLICE .)
    RBRACKET        reduce using rule 40 (stmt -> SLICE .)


state 32

    (41) stmt -> PAIR .

    SCOLON          reduce using rule 41 (stmt -> PAIR .)
    $end            reduce using rule 41 (stmt -> PAIR .)
    RBRACKET        reduce using rule 41 (stmt -> PAIR .)


state 33

    (42) stmt -> CAR .

    SCOLON          reduce using rule 42 (stmt -> CAR .)
    $end            reduce using rule 42 (stmt -> CAR .)
    RBRACKET        reduce using rule 42 (stmt -> CAR .)


state 34

    (43) stmt -> CDR .

    SCOLON          reduce using rule 43 (stmt -> CDR .)
    $end            reduce using rule 43 (stmt -> CDR .)
    RBRACKET        reduce using rule 43 (stmt -> CDR .)


state 35

    (44) stmt -> EMPTY_SET . TYPE
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 59

state 36

    (45) stmt -> MEM .

    SCOLON          reduce using rule 45 (stmt -> MEM .)
    $end            reduce using rule 45 (stmt -> MEM .)
    RBRACKET        reduce using rule 45 (stmt -> MEM .)


state 37

    (46) stmt -> UPDATE .

    SCOLON          reduce using rule 46 (stmt -> UPDATE .)
    $end            reduce using rule 46 (stmt -> UPDATE .)
    RBRACKET        reduce using rule 46 (stmt -> UPDATE .)


state 38

    (47) stmt -> SOME .

    SCOLON          reduce using rule 47 (stmt -> SOME .)
    $end            reduce using rule 47 (stmt -> SOME .)
    RBRACKET        reduce using rule 47 (stmt -> SOME .)


state 39

    (48) stmt -> NONE . TYPE
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 60

state 40

    (49) stmt -> LEFT . TYPE
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 61

state 41

    (50) stmt -> RIGHT . TYPE
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 62

state 42

    (51) stmt -> CONS .

    SCOLON          reduce using rule 51 (stmt -> CONS .)
    $end            reduce using rule 51 (stmt -> CONS .)
    RBRACKET        reduce using rule 51 (stmt -> CONS .)


state 43

    (52) stmt -> NIL . TYPE
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 63

state 44

    (53) stmt -> NOT .

    SCOLON          reduce using rule 53 (stmt -> NOT .)
    $end            reduce using rule 53 (stmt -> NOT .)
    RBRACKET        reduce using rule 53 (stmt -> NOT .)


state 45

    (54) stmt -> EXEC .

    SCOLON          reduce using rule 54 (stmt -> EXEC .)
    $end            reduce using rule 54 (stmt -> EXEC .)
    RBRACKET        reduce using rule 54 (stmt -> EXEC .)


state 46

    (62) stmt -> PUSH . TYPE value
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 64

state 47

    (63) stmt -> FAILWITH .

    SCOLON          reduce using rule 63 (stmt -> FAILWITH .)
    $end            reduce using rule 63 (stmt -> FAILWITH .)
    RBRACKET        reduce using rule 63 (stmt -> FAILWITH .)


state 48

    (2) execution -> compound_statement SCOLON .
    (5) compound_statement -> compound_statement SCOLON . stmt
    (9) stmt -> . LAMBDA TYPE TYPE body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . CONCAT
    (39) stmt -> . SIZE
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET TYPE
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . SOME
    (48) stmt -> . NONE TYPE
    (49) stmt -> . LEFT TYPE
    (50) stmt -> . RIGHT TYPE
    (51) stmt -> . CONS
    (52) stmt -> . NIL TYPE
    (53) stmt -> . NOT
    (54) stmt -> . EXEC
    (62) stmt -> . PUSH TYPE value
    (63) stmt -> . FAILWITH

    $end            reduce using rule 2 (execution -> compound_statement SCOLON .)
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    CONCAT          shift and go to state 29
    SIZE            shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    SOME            shift and go to state 38
    NONE            shift and go to state 39
    LEFT            shift and go to state 40
    RIGHT           shift and go to state 41
    CONS            shift and go to state 42
    NIL             shift and go to state 43
    NOT             shift and go to state 44
    EXEC            shift and go to state 45
    PUSH            shift and go to state 46
    FAILWITH        shift and go to state 47

    stmt                           shift and go to state 65

state 49

    (6) body -> LBRACKET compound_statement . SCOLON RBRACKET
    (7) body -> LBRACKET compound_statement . RBRACKET
    (5) compound_statement -> compound_statement . SCOLON stmt

    SCOLON          shift and go to state 66
    RBRACKET        shift and go to state 67


state 50

    (8) body -> LBRACKET RBRACKET .

    $end            reduce using rule 8 (body -> LBRACKET RBRACKET .)
    SCOLON          reduce using rule 8 (body -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 8 (body -> LBRACKET RBRACKET .)


state 51

    (9) stmt -> LAMBDA TYPE . TYPE body
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 68

state 52

    (55) TYPE -> NAT .

    NAT             reduce using rule 55 (TYPE -> NAT .)
    STRING          reduce using rule 55 (TYPE -> NAT .)
    INT             reduce using rule 55 (TYPE -> NAT .)
    BOOL            reduce using rule 55 (TYPE -> NAT .)
    BYTES           reduce using rule 55 (TYPE -> NAT .)
    OPERATION       reduce using rule 55 (TYPE -> NAT .)
    LPARENS         reduce using rule 55 (TYPE -> NAT .)
    SCOLON          reduce using rule 55 (TYPE -> NAT .)
    $end            reduce using rule 55 (TYPE -> NAT .)
    RBRACKET        reduce using rule 55 (TYPE -> NAT .)
    NUMBER          reduce using rule 55 (TYPE -> NAT .)
    TEXT            reduce using rule 55 (TYPE -> NAT .)
    TRUE            reduce using rule 55 (TYPE -> NAT .)
    FALSE           reduce using rule 55 (TYPE -> NAT .)
    LBRACKET        reduce using rule 55 (TYPE -> NAT .)
    RPARENS         reduce using rule 55 (TYPE -> NAT .)


state 53

    (56) TYPE -> STRING .

    NAT             reduce using rule 56 (TYPE -> STRING .)
    STRING          reduce using rule 56 (TYPE -> STRING .)
    INT             reduce using rule 56 (TYPE -> STRING .)
    BOOL            reduce using rule 56 (TYPE -> STRING .)
    BYTES           reduce using rule 56 (TYPE -> STRING .)
    OPERATION       reduce using rule 56 (TYPE -> STRING .)
    LPARENS         reduce using rule 56 (TYPE -> STRING .)
    SCOLON          reduce using rule 56 (TYPE -> STRING .)
    $end            reduce using rule 56 (TYPE -> STRING .)
    RBRACKET        reduce using rule 56 (TYPE -> STRING .)
    NUMBER          reduce using rule 56 (TYPE -> STRING .)
    TEXT            reduce using rule 56 (TYPE -> STRING .)
    TRUE            reduce using rule 56 (TYPE -> STRING .)
    FALSE           reduce using rule 56 (TYPE -> STRING .)
    LBRACKET        reduce using rule 56 (TYPE -> STRING .)
    RPARENS         reduce using rule 56 (TYPE -> STRING .)


state 54

    (57) TYPE -> INT .

    NAT             reduce using rule 57 (TYPE -> INT .)
    STRING          reduce using rule 57 (TYPE -> INT .)
    INT             reduce using rule 57 (TYPE -> INT .)
    BOOL            reduce using rule 57 (TYPE -> INT .)
    BYTES           reduce using rule 57 (TYPE -> INT .)
    OPERATION       reduce using rule 57 (TYPE -> INT .)
    LPARENS         reduce using rule 57 (TYPE -> INT .)
    SCOLON          reduce using rule 57 (TYPE -> INT .)
    $end            reduce using rule 57 (TYPE -> INT .)
    RBRACKET        reduce using rule 57 (TYPE -> INT .)
    NUMBER          reduce using rule 57 (TYPE -> INT .)
    TEXT            reduce using rule 57 (TYPE -> INT .)
    TRUE            reduce using rule 57 (TYPE -> INT .)
    FALSE           reduce using rule 57 (TYPE -> INT .)
    LBRACKET        reduce using rule 57 (TYPE -> INT .)
    RPARENS         reduce using rule 57 (TYPE -> INT .)


state 55

    (58) TYPE -> BOOL .

    NAT             reduce using rule 58 (TYPE -> BOOL .)
    STRING          reduce using rule 58 (TYPE -> BOOL .)
    INT             reduce using rule 58 (TYPE -> BOOL .)
    BOOL            reduce using rule 58 (TYPE -> BOOL .)
    BYTES           reduce using rule 58 (TYPE -> BOOL .)
    OPERATION       reduce using rule 58 (TYPE -> BOOL .)
    LPARENS         reduce using rule 58 (TYPE -> BOOL .)
    SCOLON          reduce using rule 58 (TYPE -> BOOL .)
    $end            reduce using rule 58 (TYPE -> BOOL .)
    RBRACKET        reduce using rule 58 (TYPE -> BOOL .)
    NUMBER          reduce using rule 58 (TYPE -> BOOL .)
    TEXT            reduce using rule 58 (TYPE -> BOOL .)
    TRUE            reduce using rule 58 (TYPE -> BOOL .)
    FALSE           reduce using rule 58 (TYPE -> BOOL .)
    LBRACKET        reduce using rule 58 (TYPE -> BOOL .)
    RPARENS         reduce using rule 58 (TYPE -> BOOL .)


state 56

    (59) TYPE -> BYTES .

    NAT             reduce using rule 59 (TYPE -> BYTES .)
    STRING          reduce using rule 59 (TYPE -> BYTES .)
    INT             reduce using rule 59 (TYPE -> BYTES .)
    BOOL            reduce using rule 59 (TYPE -> BYTES .)
    BYTES           reduce using rule 59 (TYPE -> BYTES .)
    OPERATION       reduce using rule 59 (TYPE -> BYTES .)
    LPARENS         reduce using rule 59 (TYPE -> BYTES .)
    SCOLON          reduce using rule 59 (TYPE -> BYTES .)
    $end            reduce using rule 59 (TYPE -> BYTES .)
    RBRACKET        reduce using rule 59 (TYPE -> BYTES .)
    NUMBER          reduce using rule 59 (TYPE -> BYTES .)
    TEXT            reduce using rule 59 (TYPE -> BYTES .)
    TRUE            reduce using rule 59 (TYPE -> BYTES .)
    FALSE           reduce using rule 59 (TYPE -> BYTES .)
    LBRACKET        reduce using rule 59 (TYPE -> BYTES .)
    RPARENS         reduce using rule 59 (TYPE -> BYTES .)


state 57

    (60) TYPE -> OPERATION .

    NAT             reduce using rule 60 (TYPE -> OPERATION .)
    STRING          reduce using rule 60 (TYPE -> OPERATION .)
    INT             reduce using rule 60 (TYPE -> OPERATION .)
    BOOL            reduce using rule 60 (TYPE -> OPERATION .)
    BYTES           reduce using rule 60 (TYPE -> OPERATION .)
    OPERATION       reduce using rule 60 (TYPE -> OPERATION .)
    LPARENS         reduce using rule 60 (TYPE -> OPERATION .)
    SCOLON          reduce using rule 60 (TYPE -> OPERATION .)
    $end            reduce using rule 60 (TYPE -> OPERATION .)
    RBRACKET        reduce using rule 60 (TYPE -> OPERATION .)
    NUMBER          reduce using rule 60 (TYPE -> OPERATION .)
    TEXT            reduce using rule 60 (TYPE -> OPERATION .)
    TRUE            reduce using rule 60 (TYPE -> OPERATION .)
    FALSE           reduce using rule 60 (TYPE -> OPERATION .)
    LBRACKET        reduce using rule 60 (TYPE -> OPERATION .)
    RPARENS         reduce using rule 60 (TYPE -> OPERATION .)


state 58

    (61) TYPE -> LPARENS . LPAIR TYPE TYPE RPARENS

    LPAIR           shift and go to state 69


state 59

    (44) stmt -> EMPTY_SET TYPE .

    SCOLON          reduce using rule 44 (stmt -> EMPTY_SET TYPE .)
    $end            reduce using rule 44 (stmt -> EMPTY_SET TYPE .)
    RBRACKET        reduce using rule 44 (stmt -> EMPTY_SET TYPE .)


state 60

    (48) stmt -> NONE TYPE .

    SCOLON          reduce using rule 48 (stmt -> NONE TYPE .)
    $end            reduce using rule 48 (stmt -> NONE TYPE .)
    RBRACKET        reduce using rule 48 (stmt -> NONE TYPE .)


state 61

    (49) stmt -> LEFT TYPE .

    SCOLON          reduce using rule 49 (stmt -> LEFT TYPE .)
    $end            reduce using rule 49 (stmt -> LEFT TYPE .)
    RBRACKET        reduce using rule 49 (stmt -> LEFT TYPE .)


state 62

    (50) stmt -> RIGHT TYPE .

    SCOLON          reduce using rule 50 (stmt -> RIGHT TYPE .)
    $end            reduce using rule 50 (stmt -> RIGHT TYPE .)
    RBRACKET        reduce using rule 50 (stmt -> RIGHT TYPE .)


state 63

    (52) stmt -> NIL TYPE .

    SCOLON          reduce using rule 52 (stmt -> NIL TYPE .)
    $end            reduce using rule 52 (stmt -> NIL TYPE .)
    RBRACKET        reduce using rule 52 (stmt -> NIL TYPE .)


state 64

    (62) stmt -> PUSH TYPE . value
    (16) value -> . NUMBER
    (17) value -> . bool
    (18) value -> . TEXT
    (19) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (14) bool -> . TRUE
    (15) bool -> . FALSE

    NUMBER          shift and go to state 71
    TEXT            shift and go to state 73
    LPARENS         shift and go to state 74
    TRUE            shift and go to state 75
    FALSE           shift and go to state 76

    value                          shift and go to state 70
    bool                           shift and go to state 72

state 65

    (5) compound_statement -> compound_statement SCOLON stmt .

    SCOLON          reduce using rule 5 (compound_statement -> compound_statement SCOLON stmt .)
    $end            reduce using rule 5 (compound_statement -> compound_statement SCOLON stmt .)
    RBRACKET        reduce using rule 5 (compound_statement -> compound_statement SCOLON stmt .)


state 66

    (6) body -> LBRACKET compound_statement SCOLON . RBRACKET
    (5) compound_statement -> compound_statement SCOLON . stmt
    (9) stmt -> . LAMBDA TYPE TYPE body
    (10) stmt -> . DROP
    (11) stmt -> . DUP
    (12) stmt -> . SWAP
    (13) stmt -> . UNIT
    (20) stmt -> . EQ
    (21) stmt -> . NEQ
    (22) stmt -> . LT
    (23) stmt -> . GT
    (24) stmt -> . LE
    (25) stmt -> . GE
    (26) stmt -> . OR
    (27) stmt -> . AND
    (28) stmt -> . XOR
    (29) stmt -> . COMPARE
    (30) stmt -> . NEG
    (31) stmt -> . ABS
    (32) stmt -> . ADD
    (33) stmt -> . SUB
    (34) stmt -> . MUL
    (35) stmt -> . EDIV
    (36) stmt -> . LSL
    (37) stmt -> . LSR
    (38) stmt -> . CONCAT
    (39) stmt -> . SIZE
    (40) stmt -> . SLICE
    (41) stmt -> . PAIR
    (42) stmt -> . CAR
    (43) stmt -> . CDR
    (44) stmt -> . EMPTY_SET TYPE
    (45) stmt -> . MEM
    (46) stmt -> . UPDATE
    (47) stmt -> . SOME
    (48) stmt -> . NONE TYPE
    (49) stmt -> . LEFT TYPE
    (50) stmt -> . RIGHT TYPE
    (51) stmt -> . CONS
    (52) stmt -> . NIL TYPE
    (53) stmt -> . NOT
    (54) stmt -> . EXEC
    (62) stmt -> . PUSH TYPE value
    (63) stmt -> . FAILWITH

    RBRACKET        shift and go to state 77
    LAMBDA          shift and go to state 6
    DROP            shift and go to state 7
    DUP             shift and go to state 8
    SWAP            shift and go to state 9
    UNIT            shift and go to state 10
    EQ              shift and go to state 11
    NEQ             shift and go to state 12
    LT              shift and go to state 13
    GT              shift and go to state 14
    LE              shift and go to state 15
    GE              shift and go to state 16
    OR              shift and go to state 17
    AND             shift and go to state 18
    XOR             shift and go to state 19
    COMPARE         shift and go to state 20
    NEG             shift and go to state 21
    ABS             shift and go to state 22
    ADD             shift and go to state 23
    SUB             shift and go to state 24
    MUL             shift and go to state 25
    EDIV            shift and go to state 26
    LSL             shift and go to state 27
    LSR             shift and go to state 28
    CONCAT          shift and go to state 29
    SIZE            shift and go to state 30
    SLICE           shift and go to state 31
    PAIR            shift and go to state 32
    CAR             shift and go to state 33
    CDR             shift and go to state 34
    EMPTY_SET       shift and go to state 35
    MEM             shift and go to state 36
    UPDATE          shift and go to state 37
    SOME            shift and go to state 38
    NONE            shift and go to state 39
    LEFT            shift and go to state 40
    RIGHT           shift and go to state 41
    CONS            shift and go to state 42
    NIL             shift and go to state 43
    NOT             shift and go to state 44
    EXEC            shift and go to state 45
    PUSH            shift and go to state 46
    FAILWITH        shift and go to state 47

    stmt                           shift and go to state 65

state 67

    (7) body -> LBRACKET compound_statement RBRACKET .

    $end            reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)
    SCOLON          reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)
    RBRACKET        reduce using rule 7 (body -> LBRACKET compound_statement RBRACKET .)


state 68

    (9) stmt -> LAMBDA TYPE TYPE . body
    (6) body -> . LBRACKET compound_statement SCOLON RBRACKET
    (7) body -> . LBRACKET compound_statement RBRACKET
    (8) body -> . LBRACKET RBRACKET

    LBRACKET        shift and go to state 5

    body                           shift and go to state 78

state 69

    (61) TYPE -> LPARENS LPAIR . TYPE TYPE RPARENS
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 79

state 70

    (62) stmt -> PUSH TYPE value .

    SCOLON          reduce using rule 62 (stmt -> PUSH TYPE value .)
    $end            reduce using rule 62 (stmt -> PUSH TYPE value .)
    RBRACKET        reduce using rule 62 (stmt -> PUSH TYPE value .)


state 71

    (16) value -> NUMBER .

    SCOLON          reduce using rule 16 (value -> NUMBER .)
    $end            reduce using rule 16 (value -> NUMBER .)
    RBRACKET        reduce using rule 16 (value -> NUMBER .)
    NUMBER          reduce using rule 16 (value -> NUMBER .)
    TEXT            reduce using rule 16 (value -> NUMBER .)
    LPARENS         reduce using rule 16 (value -> NUMBER .)
    TRUE            reduce using rule 16 (value -> NUMBER .)
    FALSE           reduce using rule 16 (value -> NUMBER .)
    RPARENS         reduce using rule 16 (value -> NUMBER .)


state 72

    (17) value -> bool .

    SCOLON          reduce using rule 17 (value -> bool .)
    $end            reduce using rule 17 (value -> bool .)
    RBRACKET        reduce using rule 17 (value -> bool .)
    NUMBER          reduce using rule 17 (value -> bool .)
    TEXT            reduce using rule 17 (value -> bool .)
    LPARENS         reduce using rule 17 (value -> bool .)
    TRUE            reduce using rule 17 (value -> bool .)
    FALSE           reduce using rule 17 (value -> bool .)
    RPARENS         reduce using rule 17 (value -> bool .)


state 73

    (18) value -> TEXT .

    SCOLON          reduce using rule 18 (value -> TEXT .)
    $end            reduce using rule 18 (value -> TEXT .)
    RBRACKET        reduce using rule 18 (value -> TEXT .)
    NUMBER          reduce using rule 18 (value -> TEXT .)
    TEXT            reduce using rule 18 (value -> TEXT .)
    LPARENS         reduce using rule 18 (value -> TEXT .)
    TRUE            reduce using rule 18 (value -> TEXT .)
    FALSE           reduce using rule 18 (value -> TEXT .)
    RPARENS         reduce using rule 18 (value -> TEXT .)


state 74

    (19) value -> LPARENS . PAIR_CONSTRUCTOR value value RPARENS

    PAIR_CONSTRUCTOR shift and go to state 80


state 75

    (14) bool -> TRUE .

    SCOLON          reduce using rule 14 (bool -> TRUE .)
    $end            reduce using rule 14 (bool -> TRUE .)
    RBRACKET        reduce using rule 14 (bool -> TRUE .)
    NUMBER          reduce using rule 14 (bool -> TRUE .)
    TEXT            reduce using rule 14 (bool -> TRUE .)
    LPARENS         reduce using rule 14 (bool -> TRUE .)
    TRUE            reduce using rule 14 (bool -> TRUE .)
    FALSE           reduce using rule 14 (bool -> TRUE .)
    RPARENS         reduce using rule 14 (bool -> TRUE .)


state 76

    (15) bool -> FALSE .

    SCOLON          reduce using rule 15 (bool -> FALSE .)
    $end            reduce using rule 15 (bool -> FALSE .)
    RBRACKET        reduce using rule 15 (bool -> FALSE .)
    NUMBER          reduce using rule 15 (bool -> FALSE .)
    TEXT            reduce using rule 15 (bool -> FALSE .)
    LPARENS         reduce using rule 15 (bool -> FALSE .)
    TRUE            reduce using rule 15 (bool -> FALSE .)
    FALSE           reduce using rule 15 (bool -> FALSE .)
    RPARENS         reduce using rule 15 (bool -> FALSE .)


state 77

    (6) body -> LBRACKET compound_statement SCOLON RBRACKET .

    $end            reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    SCOLON          reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)
    RBRACKET        reduce using rule 6 (body -> LBRACKET compound_statement SCOLON RBRACKET .)


state 78

    (9) stmt -> LAMBDA TYPE TYPE body .

    SCOLON          reduce using rule 9 (stmt -> LAMBDA TYPE TYPE body .)
    $end            reduce using rule 9 (stmt -> LAMBDA TYPE TYPE body .)
    RBRACKET        reduce using rule 9 (stmt -> LAMBDA TYPE TYPE body .)


state 79

    (61) TYPE -> LPARENS LPAIR TYPE . TYPE RPARENS
    (55) TYPE -> . NAT
    (56) TYPE -> . STRING
    (57) TYPE -> . INT
    (58) TYPE -> . BOOL
    (59) TYPE -> . BYTES
    (60) TYPE -> . OPERATION
    (61) TYPE -> . LPARENS LPAIR TYPE TYPE RPARENS

    NAT             shift and go to state 52
    STRING          shift and go to state 53
    INT             shift and go to state 54
    BOOL            shift and go to state 55
    BYTES           shift and go to state 56
    OPERATION       shift and go to state 57
    LPARENS         shift and go to state 58

    TYPE                           shift and go to state 81

state 80

    (19) value -> LPARENS PAIR_CONSTRUCTOR . value value RPARENS
    (16) value -> . NUMBER
    (17) value -> . bool
    (18) value -> . TEXT
    (19) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (14) bool -> . TRUE
    (15) bool -> . FALSE

    NUMBER          shift and go to state 71
    TEXT            shift and go to state 73
    LPARENS         shift and go to state 74
    TRUE            shift and go to state 75
    FALSE           shift and go to state 76

    value                          shift and go to state 82
    bool                           shift and go to state 72

state 81

    (61) TYPE -> LPARENS LPAIR TYPE TYPE . RPARENS

    RPARENS         shift and go to state 83


state 82

    (19) value -> LPARENS PAIR_CONSTRUCTOR value . value RPARENS
    (16) value -> . NUMBER
    (17) value -> . bool
    (18) value -> . TEXT
    (19) value -> . LPARENS PAIR_CONSTRUCTOR value value RPARENS
    (14) bool -> . TRUE
    (15) bool -> . FALSE

    NUMBER          shift and go to state 71
    TEXT            shift and go to state 73
    LPARENS         shift and go to state 74
    TRUE            shift and go to state 75
    FALSE           shift and go to state 76

    value                          shift and go to state 84
    bool                           shift and go to state 72

state 83

    (61) TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .

    NAT             reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    STRING          reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    INT             reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    BOOL            reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    BYTES           reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    OPERATION       reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    LPARENS         reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    SCOLON          reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    $end            reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    RBRACKET        reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    NUMBER          reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    TEXT            reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    TRUE            reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    FALSE           reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    LBRACKET        reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)
    RPARENS         reduce using rule 61 (TYPE -> LPARENS LPAIR TYPE TYPE RPARENS .)


state 84

    (19) value -> LPARENS PAIR_CONSTRUCTOR value value . RPARENS

    RPARENS         shift and go to state 85


state 85

    (19) value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .

    SCOLON          reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    $end            reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RBRACKET        reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    NUMBER          reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TEXT            reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    LPARENS         reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    TRUE            reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    FALSE           reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)
    RPARENS         reduce using rule 19 (value -> LPARENS PAIR_CONSTRUCTOR value value RPARENS .)

