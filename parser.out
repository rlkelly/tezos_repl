Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EMPTY_MAP
    GET
    LBRACKET
    RBRACKET

Grammar

Rule 0     S' -> statement
Rule 1     statement -> DROP
Rule 2     statement -> DUP
Rule 3     statement -> SWAP
Rule 4     statement -> UNIT
Rule 5     bool -> TRUE
Rule 6     bool -> FALSE
Rule 7     value -> NUMBER
Rule 8     value -> bool
Rule 9     value -> TEXT
Rule 10    statement -> EQ
Rule 11    statement -> NEQ
Rule 12    statement -> LT
Rule 13    statement -> GT
Rule 14    statement -> LE
Rule 15    statement -> GE
Rule 16    statement -> OR
Rule 17    statement -> AND
Rule 18    statement -> XOR
Rule 19    statement -> COMPARE
Rule 20    statement -> NEG
Rule 21    statement -> ABS
Rule 22    statement -> ADD
Rule 23    statement -> SUB
Rule 24    statement -> MUL
Rule 25    statement -> EDIV
Rule 26    statement -> LSL
Rule 27    statement -> LSR
Rule 28    statement -> CONCAT
Rule 29    statement -> SIZE
Rule 30    statement -> SLICE
Rule 31    statement -> PAIR
Rule 32    statement -> CAR
Rule 33    statement -> CDR
Rule 34    statement -> EMPTY_SET TYPE
Rule 35    statement -> MEM
Rule 36    statement -> UPDATE
Rule 37    statement -> SOME
Rule 38    statement -> NONE TYPE
Rule 39    statement -> CONS
Rule 40    statement -> NIL TYPE
Rule 41    statement -> NOT
Rule 42    TYPE -> NAT
Rule 43    TYPE -> STRING
Rule 44    TYPE -> INT
Rule 45    TYPE -> BOOL
Rule 46    TYPE -> BYTES
Rule 47    statement -> PUSH TYPE value
Rule 48    statement -> FAILWITH

Terminals, with rules where they appear

ABS                  : 21
ADD                  : 22
AND                  : 17
BOOL                 : 45
BYTES                : 46
CAR                  : 32
CDR                  : 33
COMPARE              : 19
CONCAT               : 28
CONS                 : 39
DROP                 : 1
DUP                  : 2
EDIV                 : 25
EMPTY_MAP            : 
EMPTY_SET            : 34
EQ                   : 10
FAILWITH             : 48
FALSE                : 6
GE                   : 15
GET                  : 
GT                   : 13
INT                  : 44
LBRACKET             : 
LE                   : 14
LSL                  : 26
LSR                  : 27
LT                   : 12
MEM                  : 35
MUL                  : 24
NAT                  : 42
NEG                  : 20
NEQ                  : 11
NIL                  : 40
NONE                 : 38
NOT                  : 41
NUMBER               : 7
OR                   : 16
PAIR                 : 31
PUSH                 : 47
RBRACKET             : 
SIZE                 : 29
SLICE                : 30
SOME                 : 37
STRING               : 43
SUB                  : 23
SWAP                 : 3
TEXT                 : 9
TRUE                 : 5
UNIT                 : 4
UPDATE               : 36
XOR                  : 18
error                : 

Nonterminals, with rules where they appear

TYPE                 : 34 38 40 47
bool                 : 8
statement            : 0
value                : 47

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . DROP
    (2) statement -> . DUP
    (3) statement -> . SWAP
    (4) statement -> . UNIT
    (10) statement -> . EQ
    (11) statement -> . NEQ
    (12) statement -> . LT
    (13) statement -> . GT
    (14) statement -> . LE
    (15) statement -> . GE
    (16) statement -> . OR
    (17) statement -> . AND
    (18) statement -> . XOR
    (19) statement -> . COMPARE
    (20) statement -> . NEG
    (21) statement -> . ABS
    (22) statement -> . ADD
    (23) statement -> . SUB
    (24) statement -> . MUL
    (25) statement -> . EDIV
    (26) statement -> . LSL
    (27) statement -> . LSR
    (28) statement -> . CONCAT
    (29) statement -> . SIZE
    (30) statement -> . SLICE
    (31) statement -> . PAIR
    (32) statement -> . CAR
    (33) statement -> . CDR
    (34) statement -> . EMPTY_SET TYPE
    (35) statement -> . MEM
    (36) statement -> . UPDATE
    (37) statement -> . SOME
    (38) statement -> . NONE TYPE
    (39) statement -> . CONS
    (40) statement -> . NIL TYPE
    (41) statement -> . NOT
    (47) statement -> . PUSH TYPE value
    (48) statement -> . FAILWITH

    DROP            shift and go to state 2
    DUP             shift and go to state 3
    SWAP            shift and go to state 4
    UNIT            shift and go to state 5
    EQ              shift and go to state 6
    NEQ             shift and go to state 7
    LT              shift and go to state 8
    GT              shift and go to state 9
    LE              shift and go to state 10
    GE              shift and go to state 11
    OR              shift and go to state 12
    AND             shift and go to state 13
    XOR             shift and go to state 14
    COMPARE         shift and go to state 15
    NEG             shift and go to state 16
    ABS             shift and go to state 17
    ADD             shift and go to state 18
    SUB             shift and go to state 19
    MUL             shift and go to state 20
    EDIV            shift and go to state 21
    LSL             shift and go to state 22
    LSR             shift and go to state 23
    CONCAT          shift and go to state 24
    SIZE            shift and go to state 25
    SLICE           shift and go to state 26
    PAIR            shift and go to state 27
    CAR             shift and go to state 28
    CDR             shift and go to state 29
    EMPTY_SET       shift and go to state 30
    MEM             shift and go to state 31
    UPDATE          shift and go to state 32
    SOME            shift and go to state 33
    NONE            shift and go to state 34
    CONS            shift and go to state 35
    NIL             shift and go to state 36
    NOT             shift and go to state 37
    PUSH            shift and go to state 38
    FAILWITH        shift and go to state 39

    statement                      shift and go to state 1

state 1

    (0) S' -> statement .



state 2

    (1) statement -> DROP .

    $end            reduce using rule 1 (statement -> DROP .)


state 3

    (2) statement -> DUP .

    $end            reduce using rule 2 (statement -> DUP .)


state 4

    (3) statement -> SWAP .

    $end            reduce using rule 3 (statement -> SWAP .)


state 5

    (4) statement -> UNIT .

    $end            reduce using rule 4 (statement -> UNIT .)


state 6

    (10) statement -> EQ .

    $end            reduce using rule 10 (statement -> EQ .)


state 7

    (11) statement -> NEQ .

    $end            reduce using rule 11 (statement -> NEQ .)


state 8

    (12) statement -> LT .

    $end            reduce using rule 12 (statement -> LT .)


state 9

    (13) statement -> GT .

    $end            reduce using rule 13 (statement -> GT .)


state 10

    (14) statement -> LE .

    $end            reduce using rule 14 (statement -> LE .)


state 11

    (15) statement -> GE .

    $end            reduce using rule 15 (statement -> GE .)


state 12

    (16) statement -> OR .

    $end            reduce using rule 16 (statement -> OR .)


state 13

    (17) statement -> AND .

    $end            reduce using rule 17 (statement -> AND .)


state 14

    (18) statement -> XOR .

    $end            reduce using rule 18 (statement -> XOR .)


state 15

    (19) statement -> COMPARE .

    $end            reduce using rule 19 (statement -> COMPARE .)


state 16

    (20) statement -> NEG .

    $end            reduce using rule 20 (statement -> NEG .)


state 17

    (21) statement -> ABS .

    $end            reduce using rule 21 (statement -> ABS .)


state 18

    (22) statement -> ADD .

    $end            reduce using rule 22 (statement -> ADD .)


state 19

    (23) statement -> SUB .

    $end            reduce using rule 23 (statement -> SUB .)


state 20

    (24) statement -> MUL .

    $end            reduce using rule 24 (statement -> MUL .)


state 21

    (25) statement -> EDIV .

    $end            reduce using rule 25 (statement -> EDIV .)


state 22

    (26) statement -> LSL .

    $end            reduce using rule 26 (statement -> LSL .)


state 23

    (27) statement -> LSR .

    $end            reduce using rule 27 (statement -> LSR .)


state 24

    (28) statement -> CONCAT .

    $end            reduce using rule 28 (statement -> CONCAT .)


state 25

    (29) statement -> SIZE .

    $end            reduce using rule 29 (statement -> SIZE .)


state 26

    (30) statement -> SLICE .

    $end            reduce using rule 30 (statement -> SLICE .)


state 27

    (31) statement -> PAIR .

    $end            reduce using rule 31 (statement -> PAIR .)


state 28

    (32) statement -> CAR .

    $end            reduce using rule 32 (statement -> CAR .)


state 29

    (33) statement -> CDR .

    $end            reduce using rule 33 (statement -> CDR .)


state 30

    (34) statement -> EMPTY_SET . TYPE
    (42) TYPE -> . NAT
    (43) TYPE -> . STRING
    (44) TYPE -> . INT
    (45) TYPE -> . BOOL
    (46) TYPE -> . BYTES

    NAT             shift and go to state 41
    STRING          shift and go to state 42
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    BYTES           shift and go to state 45

    TYPE                           shift and go to state 40

state 31

    (35) statement -> MEM .

    $end            reduce using rule 35 (statement -> MEM .)


state 32

    (36) statement -> UPDATE .

    $end            reduce using rule 36 (statement -> UPDATE .)


state 33

    (37) statement -> SOME .

    $end            reduce using rule 37 (statement -> SOME .)


state 34

    (38) statement -> NONE . TYPE
    (42) TYPE -> . NAT
    (43) TYPE -> . STRING
    (44) TYPE -> . INT
    (45) TYPE -> . BOOL
    (46) TYPE -> . BYTES

    NAT             shift and go to state 41
    STRING          shift and go to state 42
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    BYTES           shift and go to state 45

    TYPE                           shift and go to state 46

state 35

    (39) statement -> CONS .

    $end            reduce using rule 39 (statement -> CONS .)


state 36

    (40) statement -> NIL . TYPE
    (42) TYPE -> . NAT
    (43) TYPE -> . STRING
    (44) TYPE -> . INT
    (45) TYPE -> . BOOL
    (46) TYPE -> . BYTES

    NAT             shift and go to state 41
    STRING          shift and go to state 42
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    BYTES           shift and go to state 45

    TYPE                           shift and go to state 47

state 37

    (41) statement -> NOT .

    $end            reduce using rule 41 (statement -> NOT .)


state 38

    (47) statement -> PUSH . TYPE value
    (42) TYPE -> . NAT
    (43) TYPE -> . STRING
    (44) TYPE -> . INT
    (45) TYPE -> . BOOL
    (46) TYPE -> . BYTES

    NAT             shift and go to state 41
    STRING          shift and go to state 42
    INT             shift and go to state 43
    BOOL            shift and go to state 44
    BYTES           shift and go to state 45

    TYPE                           shift and go to state 48

state 39

    (48) statement -> FAILWITH .

    $end            reduce using rule 48 (statement -> FAILWITH .)


state 40

    (34) statement -> EMPTY_SET TYPE .

    $end            reduce using rule 34 (statement -> EMPTY_SET TYPE .)


state 41

    (42) TYPE -> NAT .

    $end            reduce using rule 42 (TYPE -> NAT .)
    NUMBER          reduce using rule 42 (TYPE -> NAT .)
    TEXT            reduce using rule 42 (TYPE -> NAT .)
    TRUE            reduce using rule 42 (TYPE -> NAT .)
    FALSE           reduce using rule 42 (TYPE -> NAT .)


state 42

    (43) TYPE -> STRING .

    $end            reduce using rule 43 (TYPE -> STRING .)
    NUMBER          reduce using rule 43 (TYPE -> STRING .)
    TEXT            reduce using rule 43 (TYPE -> STRING .)
    TRUE            reduce using rule 43 (TYPE -> STRING .)
    FALSE           reduce using rule 43 (TYPE -> STRING .)


state 43

    (44) TYPE -> INT .

    $end            reduce using rule 44 (TYPE -> INT .)
    NUMBER          reduce using rule 44 (TYPE -> INT .)
    TEXT            reduce using rule 44 (TYPE -> INT .)
    TRUE            reduce using rule 44 (TYPE -> INT .)
    FALSE           reduce using rule 44 (TYPE -> INT .)


state 44

    (45) TYPE -> BOOL .

    $end            reduce using rule 45 (TYPE -> BOOL .)
    NUMBER          reduce using rule 45 (TYPE -> BOOL .)
    TEXT            reduce using rule 45 (TYPE -> BOOL .)
    TRUE            reduce using rule 45 (TYPE -> BOOL .)
    FALSE           reduce using rule 45 (TYPE -> BOOL .)


state 45

    (46) TYPE -> BYTES .

    $end            reduce using rule 46 (TYPE -> BYTES .)
    NUMBER          reduce using rule 46 (TYPE -> BYTES .)
    TEXT            reduce using rule 46 (TYPE -> BYTES .)
    TRUE            reduce using rule 46 (TYPE -> BYTES .)
    FALSE           reduce using rule 46 (TYPE -> BYTES .)


state 46

    (38) statement -> NONE TYPE .

    $end            reduce using rule 38 (statement -> NONE TYPE .)


state 47

    (40) statement -> NIL TYPE .

    $end            reduce using rule 40 (statement -> NIL TYPE .)


state 48

    (47) statement -> PUSH TYPE . value
    (7) value -> . NUMBER
    (8) value -> . bool
    (9) value -> . TEXT
    (5) bool -> . TRUE
    (6) bool -> . FALSE

    NUMBER          shift and go to state 50
    TEXT            shift and go to state 52
    TRUE            shift and go to state 53
    FALSE           shift and go to state 54

    value                          shift and go to state 49
    bool                           shift and go to state 51

state 49

    (47) statement -> PUSH TYPE value .

    $end            reduce using rule 47 (statement -> PUSH TYPE value .)


state 50

    (7) value -> NUMBER .

    $end            reduce using rule 7 (value -> NUMBER .)


state 51

    (8) value -> bool .

    $end            reduce using rule 8 (value -> bool .)


state 52

    (9) value -> TEXT .

    $end            reduce using rule 9 (value -> TEXT .)


state 53

    (5) bool -> TRUE .

    $end            reduce using rule 5 (bool -> TRUE .)


state 54

    (6) bool -> FALSE .

    $end            reduce using rule 6 (bool -> FALSE .)

